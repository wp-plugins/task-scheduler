<?php 
/**
	Task Scheduler - Minified Classes v1.0.0b08 by miunosoft (Michael Uno) 
	Generated by the PHP Class Minifier
	<http://en.michaeluno.jp/>
	Copyright (c) 2014, Michael Uno; Licensed under GPL v2 or later */
 if ( ! class_exists( 'TaskScheduler_Registry_Base' ) ) { include_once( dirname( dirname( dirname( __FILE__ ) ) ) . '/task-scheduler.php' ); } class TaskScheduler_InclusionScriptHeader extends TaskScheduler_Registry_Base { const Name = 'Task Scheduler - PHP Class Inclusion Script'; const Description = 'Generated by the PHP Class Inclusion Script Creator'; }if ( ! class_exists( 'TaskScheduler_Registry_Base' ) ) { include_once( dirname( dirname( dirname( __FILE__ ) ) ) . '/task-scheduler.php' ); } class TaskScheduler_MinifiedVersionHeader extends TaskScheduler_Registry_Base { const Name = 'Task Scheduler - Minified Classes'; const Description = 'Generated by the PHP Class Minifier'; }abstract class TaskScheduler_MetaBox_Base extends TaskScheduler_AdminPageFramework_MetaBox { public function start() { if ( isset( $GLOBALS['pagenow'] ) && 'post.php' === $GLOBALS['pagenow'] ) { add_action( 'current_screen', array( $this, '_replyToRegisterFieldTypes' ) ); add_action( 'admin_enqueue_scripts', array( $this, '_replyToAddCSS' ), 10, 1 ); } } public function _replyToRegisterFieldTypes( $oScreen ) { if ( ! in_array( $oScreen->post_type, array( TaskScheduler_Registry::PostType_Task, TaskScheduler_Registry::PostType_Thread ) ) ) { return; } $_sClassName = get_class( $this ); new TaskScheduler_DateTimeCustomFieldType( $_sClassName ); new TaskScheduler_TimeCustomFieldType( $_sClassName ); new TaskScheduler_DateCustomFieldType( $_sClassName ); } public function _replyToAddCSS( $sHook ) { global $post; if ( ! in_array( $sHook, array( 'post.php', 'post-new.php' ) ) ) { return; } if ( ! in_array( $post->post_type, array( TaskScheduler_Registry::PostType_Task, TaskScheduler_Registry::PostType_Thread ) ) ) { return; } wp_enqueue_style( 'task_scheduler_meta_box_css', TaskScheduler_Registry::getPluginURL( 'asset/css/meta_box.css' ) ); } protected function _getModuleFields( $sModuleSlug, array $aModularOptions ) { $_aFields = array(); if ( empty( $aModularOptions ) ) { return $_aFields; } $_aModularFields = array(); $_aWizardSlugs = apply_filters( "task_scheduler_admin_filter_wizard_slugs_{$sModuleSlug}", array() ); foreach( $_aWizardSlugs as $sSlug ) { $_aWizardFieldsWithSection = apply_filters( "task_scheduler_filter_fields_{$sSlug}", array() ); $_aWizardFields = isset( $_aWizardFieldsWithSection[ $sSlug ] ) ? $_aWizardFieldsWithSection[ $sSlug ] : array(); $_aModularFields = $_aModularFields + $_aWizardFields; } foreach( $aModularOptions as $_sKey => $_aisValue ) { if ( ! isset( $_aModularFields[ $_sKey ] ) ) { continue; } $_aModularField = $_aModularFields[ $_sKey ]; $_aisValue = TaskScheduler_Utility::isJSON( $_aisValue ) ? json_decode( $_aisValue, true ) : $_aisValue; $_aisValue = maybe_unserialize( $_aisValue ); if ( in_array( $_aModularField['type'], array( 'select', 'radio' ) ) && ! is_array( $_aisValue ) ) { $_aisValue = isset( $_aModularField['label'][ $_aisValue ] ) ? $_aModularField['label'][ $_aisValue ] : $_aisValue; } $_aModularField = array( 'attributes' => array( 'ReadOnly' => 'ReadOnly', 'name' => '', 'class' => 'read-only', ), 'field_id' => $_aModularField['field_id'], 'type' => $this->_getFieldTypeToOnlyDisplay( $_aisValue, $_aModularField['type'] ), 'value' => $_aisValue, 'title' => $_aModularField['title'], ); $_aModularField['attributes']['cols'] = 'textarea' == $_aModularField['type'] ? 42 : null; if ( is_array( $_aisValue ) ) { $_aModularField['before_fieldset'] = "<div class='task-scheduler-module-options-value-container'>" . TaskScheduler_PluginUtility::getListFromAssociativeArray( array( __( 'Key', 'task-scheduler' ) => __( 'Value', 'task-scheduler' ) ) + $_aisValue ) . "</div>"; } $_aFields[ $_aModularField['field_id'] ] = $_aModularField; } return $_aFields; } protected function _getModuleEditButtonField( $sFieldID, $sTabSlug ) { $_sModuleEditPageURL = TaskScheduler_PluginUtility::getModuleEditPageURL( array( 'transient_key' => TaskScheduler_Registry::TransientPrefix . uniqid(), 'tab' => $sTabSlug, 'post' => isset( $_GET['post'] ) ? $_GET['post'] : 0, ) ); return array( 'field_id' => $sFieldID, 'type' => 'hidden', 'value' => '', 'before_field' => "<div style='float:right;'>" . "<a class='button button-secondary button-large' href='{$_sModuleEditPageURL}'>" . __( 'Change', 'task-scheduler' ) . "</a>" . "</div>", 'attributes' => array( 'name' => '', ), ); } protected function _getFieldTypeToOnlyDisplay( $aisValue, $sSetFieldType ) { if ( is_array( $aisValue ) ) { return 'hidden'; } if ( 'textarea' === $sSetFieldType ) { return $sSetFieldType; } return 'text'; } }class TaskScheduler_MetaBox_Action extends TaskScheduler_MetaBox_Base { public function setUp() { $this->_oTask = isset( $_GET['post'] ) ? TaskScheduler_Routine::getInstance( $_GET['post'] ) : null; $_sModuleEditPageURL = TaskScheduler_PluginUtility::getModuleEditPageURL( array( 'transient_key' => TaskScheduler_Registry::TransientPrefix . uniqid(), 'tab' => 'edit_action', 'post' => isset( $_GET['post'] ) ? $_GET['post'] : 0, ) ); $this->addSettingFields( array( 'field_id' => 'routine_action', 'title' => __( 'Action', 'task-scheduler' ), 'type' => 'text', 'attributes' => array( 'ReadOnly' => 'ReadOnly', 'name' => '', ), ), array( 'field_id' => 'argument', 'title' => __( 'Arguments', 'task-scheduler' ), 'type' => 'text', 'repeatable' => true, ), array() ); } public function field_definition_TaskScheduler_MetaBox_Action_routine_action( $aField ) { if ( ! $this->_oTask ) { return $aField; } $aField['value'] = apply_filters( "task_scheduler_filter_label_action_{$this->_oTask->routine_action}", $this->_oTask->routine_action ); return $aField; } public function field_definition_TaskScheduler_MetaBox_Action( $aAllFields ) { if ( ! $this->_oTask ) { return $aAllFields; } if ( ! isset( $aAllFields['_default'] ) || ! is_array( $aAllFields['_default'] ) ) { return $aAllFields; } $aAllFields['_default'] = $aAllFields['_default'] + $this->_getModuleFields( $this->_oTask->routine_action, $this->_oTask->{$this->_oTask->routine_action} ) + array( 'wizard_redirect_button_action' => $this->_getModuleEditButtonField( 'wizard_redirect_button_action', 'edit_action' ) ); return $aAllFields; } public function validation_TaskScheduler_MetaBox_Action( $aInput, $aOldInput ) { return $aInput; } }class TaskScheduler_MetaBox_Advanced extends TaskScheduler_MetaBox_Base { public function setUp() { $this->addSettingFields( array( 'field_id' => '_max_root_log_count', 'title' => __( 'Max Count of Log Entries', 'task-scheduler' ), 'type' => 'number', 'attributes' => array( 'min' => 0, 'step' => 1, ), 'description' => __( 'Set the maximum number of log items.', 'task-scheduler' ) . ' ' . __( 'Set 0 to disable it.', 'task-scheduler' ), ), array( 'field_id' => '_max_execution_time', 'title' => __( 'Max Task Execution Time', 'task-scheduler' ), 'type' => 'number', 'after_label' => ' ' .__( 'second(s)', 'task-scheduler' ), 'description' => __( 'Set the expected duration that the task will take to complete.', 'task-scheduler' ), 'attributes' => array( 'min' => 0, 'step' => 1, 'max' => TaskScheduler_WPUtility::canUseIniSet() ? null : TaskScheduler_WPUtility::getServerAllowedMaxExecutionTime( 30 ), ), ), array( 'field_id' => '_force_execution', 'title' => __( 'Force Execution', 'task-scheduler' ), 'type' => 'checkbox', 'label' => __( 'Execute the action even when the last routine is not completed.', 'task-scheduler' ), 'default' => false, ), array() ); } public function validation_TaskScheduler_MetaBox_Advanced( $aInput, $aOldInput ) { if ( isset( $aInput['_max_root_log_count'] ) ) { $aInput['_max_root_log_count'] = $this->oUtil->fixNumber( $aInput['_max_root_log_count'], TaskScheduler_Option::get( array( 'task_default', 'max_root_log_count' ) ), 0 ); } if ( isset( $aInput['_max_execution_time'] ) ) { $aInput['_max_execution_time'] = $this->oUtil->fixNumber( $aInput['_max_execution_time'], TaskScheduler_Option::get( array( 'task_default', 'max_execution_time' ) ), 0 ); } $this->_checkLogs( $aInput['_max_root_log_count'] ); return $aInput; } private function _checkLogs( $iMaxRootLogCount ) { if ( ! isset( $_REQUEST['post_ID'] ) ) { return; } $_iTaskID = $_REQUEST['post_ID']; $_oTask = TaskScheduler_Routine::getInstance( $_iTaskID ); if ( ! is_object( $_oTask ) ) { return; } if ( $_oTask->getRootLogCount() > ( int ) $iMaxRootLogCount ) { wp_schedule_single_event( time(), 'task_scheduler_action_add_log_deletion_task', array( $_iTaskID ) ); } } }class TaskScheduler_MetaBox_Main extends TaskScheduler_MetaBox_Base { public function setUp() { $this->addSettingFields( array( 'field_id' => 'excerpt', 'title' => __( 'Description', 'task-scheduler' ), 'type' => 'textarea', ), array() ); } public function field_definition_TaskScheduler_MetaBox_Main_excerpt( $aField ) { if ( isset( $_GET['post'] ) ) { $_oPost = get_post( $_GET['post'] ); $aField['value'] = $_oPost->post_excerpt; } return $aField; } public function validation_TaskScheduler_MetaBox_Main( $aInput, $aOldInput ) { return $aInput; } }class TaskScheduler_MetaBox_Occurrence extends TaskScheduler_MetaBox_Base { public function setUp() { $this->_oTask = isset( $_GET['post'] ) ? TaskScheduler_Routine::getInstance( $_GET['post'] ) : null; $this->addSettingFields( array( 'field_id' => 'occurrence', 'title' => __( 'Occurrence', 'task-scheduler' ), 'type' => 'text', 'attributes' => array( 'ReadOnly' => 'ReadOnly', 'name' => '', ), ), array() ); } public function field_definition_TaskScheduler_MetaBox_Occurrence_occurrence( $aField ) { if ( ! $this->_oTask ) { return $aField; } $aField['value'] = apply_filters( "task_scheduler_filter_label_occurrence_{$this->_oTask->occurrence}", $this->_oTask->occurrence ); return $aField; } public function field_definition_TaskScheduler_MetaBox_Occurrence( $aAllFields ) { if ( ! $this->_oTask ) { return $aAllFields; } if ( ! isset( $aAllFields['_default'] ) || ! is_array( $aAllFields['_default'] ) ) { return $aAllFields; } $aAllFields['_default'] = $aAllFields['_default'] + $this->_getModuleFields( $this->_oTask->occurrence, $this->_oTask->{$this->_oTask->occurrence} ) + array( 'wizard_redirect_button_occurrence' => $this->_getModuleEditButtonField( 'wizard_redirect_button_occurrence', 'edit_occurrence' ) ); return $aAllFields; } public function validation_TaskScheduler_MetaBox_Occurrence( $aInput, $aOldInput ) { return $aInput; } }class TaskScheduler_MetaBox_Submit extends TaskScheduler_MetaBox_Base { public function start() { parent::start(); add_action( 'admin_menu', array( $this, '_replyToRemoveDefaultMetaBoxes' ) ); } public function _replyToRemoveDefaultMetaBoxes() { remove_meta_box( 'submitdiv', TaskScheduler_Registry::PostType_Task, 'side' ); } public function setUp() { $this->_iRoutineID = isset( $_GET['post'] ) ? $_GET['post'] : 0; $this->addSettingFields( array( 'field_id' => 'label_last_run_time', 'type' => 'text', 'title' => __( 'Last Run Time', 'task-scheduler' ), 'attributes' => array( 'readonly' => 'ReadOnly', 'name' => '', 'size' => 16, ), ), array( 'field_id' => 'label_next_run_time', 'type' => 'text', 'title' => __( 'Next Run Time', 'task-scheduler' ), 'attributes' => array( 'readonly' => 'ReadOnly', 'name' => '', 'size' => 16, ), ), array( 'field_id' => '_is_enabled', 'type' => 'radio', 'title' => __( 'Switch', 'task-scheduler' ), 'label' => array( 1 => __( 'Enabled', 'task-scheduler' ), 0 => __( 'Disabled', 'task-scheduler' ), ), ), array( 'field_id' => 'task_submit', 'type' => 'submit', 'value' => __( 'Update', 'task-scheduler' ), 'attributes' => array( 'style' => 'float:right;', ), ), array() ); } public function field_definition_TaskScheduler_MetaBox_Submit_label_last_run_time( $aField ) { if ( ! $this->_iRoutineID ) { return $aField; } $this->_oRoutine = isset( $this->_oRoutine ) ? $this->_oRoutine : TaskScheduler_Routine::getInstance( $this->_iRoutineID ); $aField['value'] = $this->_oRoutine->getReadableTime( $this->_oRoutine->_last_run_time, 'Y/m/d G:i:s', true ); return $aField; } public function field_definition_TaskScheduler_MetaBox_Submit_label_next_run_time( $aField ) { if ( ! $this->_iRoutineID ) { return $aField; } $this->_oRoutine = isset( $this->_oRoutine ) ? $this->_oRoutine : TaskScheduler_Routine::getInstance( $this->_iRoutineID ); $aField['value'] = $this->_oRoutine->getReadableTime( $this->_oRoutine->_next_run_time, 'Y/m/d G:i:s', true ); return $aField; } public function field_definition_TaskScheduler_MetaBox_Submit__is_enabled( $aField ) { if ( ! $this->_iRoutineID ) { return $aField; } $this->_oRoutine = isset( $this->_oRoutine ) ? $this->_oRoutine : TaskScheduler_Routine::getInstance( $this->_iRoutineID ); $aField['value'] = $this->_oRoutine->isEnabled() ? 1 : 0; return $aField; } public function validation_TaskScheduler_MetaBox_Submit( $aInput, $aOldInput ) { $_bShouldBeEnabled = $aInput['_is_enabled'] ? true : false; $_sEnableOrDisable = $aInput['_is_enabled'] ? 'enable' : 'disable'; unset( $aInput[ '_is_enabled' ], $aInput['task_submit'] ); $_iRoutineID = isset( $_POST['post_ID'] ) ? $_POST['post_ID'] : ( isset( $_POST['ID'] ) ? $_POST['ID'] : 0 ); $_oRoutine = TaskScheduler_Routine::getInstance( $_iRoutineID ); $_bisEnabled = $_oRoutine->isEnabled() ? true : false; if ( $_bisEnabled !== $_bShouldBeEnabled ) { $_oRoutine->{$_sEnableOrDisable}(); } return $aInput; } }abstract class TaskScheduler_AdminPage_Start extends TaskScheduler_AdminPageFramework { public function start() { if ( in_array( $this->oProp->sPageNow, array( 'plugins.php' ) ) && 'plugin' == $this->oProp->aScriptInfo['sType'] ) { add_filter( 'plugin_action_links_' . plugin_basename( $this->oProp->aScriptInfo['sPath'] ), array( $this, '_replyToInsertLink' ), 100 ); } add_filter( 'redirect_post_location', array( $this, '_replyToModifyRedirectURLAfterUpdatingTask' ), 10, 2 ); } public function _replyToInsertLink( $aLinks ) { $_sLink = add_query_arg( array( 'page' => TaskScheduler_Registry::AdminPage_TaskList, ), admin_url( 'admin.php' ) ); array_unshift( $aLinks, "<a href='{$_sLink}'>" . __( 'Manage Tasks', 'task-scheduler' ) . "</a>" ); return $aLinks; } public function _replyToModifyRedirectURLAfterUpdatingTask( $sURL, $iPostID ) { $_sPostType = get_post_type( $iPostID ); if ( in_array( $_sPostType, array( TaskScheduler_Registry::PostType_Task, TaskScheduler_Registry::PostType_Thread ) ) ) { $_oRoutine = TaskScheduler_Routine::getInstance( $iPostID ); $_aQueryArgs = ! $_oRoutine->isEnabled() ? array( 'status' => 'disabled' ) : array(); return TaskScheduler_PluginUtility::getTaskListingPageURL( $_aQueryArgs ); } return $sURL; } }abstract class TaskScheduler_AdminPage_Form extends TaskScheduler_AdminPage_Start { public function load_ts_task_list() { $this->_setTaskListingTableForm(); $this->_oTaskListTable = new TaskScheduler_ListTable; $this->_oTaskListTable->process_bulk_action(); $_sStatus = isset( $_GET['status'] ) ? $_GET['status'] : 'enabled'; $_oEnabled = $this->_getTasks( 'enabled' ); $_oDisabled = $this->_getTasks( 'disabled' ); $_oSystem = $this->_getTasks( 'system' ); $_oThreads = $this->_getTasks( 'thread' ); switch( strtolower( $_sStatus ) ) { default: case 'enabled': $_aTasks = $_oEnabled->posts; break; case 'disabled': $_aTasks = $_oDisabled->posts; break; case 'system': $_aTasks = $_oSystem->posts; break; case 'thread': $_aTasks = $_oThreads->posts; break; } $this->_oTaskListTable->aData = $_aTasks; $this->_oTaskListTable->_iEnabledTasks = $_oEnabled->found_posts; $this->_oTaskListTable->_iDisabledTasks = $_oDisabled->found_posts; $this->_oTaskListTable->_iSystemTasks = $_oSystem->found_posts; $this->_oTaskListTable->_iThreadTasks = $_oThreads->found_posts; } private function _getTasks( $sLabel ) { $_aQueryArgs = array(); if ( isset( $_GET['orderby'], $_GET['order'] ) ) { $_aQueryArgs['meta_key'] = $_GET['orderby']; $_aQueryArgs['order'] = strtoupper( $_GET['order'] ); } switch( strtolower( $sLabel ) ) { default: case 'enabled': $_aQueryArgs = array( 'post_status' => array( 'private', ), 'tax_query' => array( 'relation' => 'AND', array( 'taxonomy' => TaskScheduler_Registry::Taxonomy_SystemLabel, 'field' => 'slug', 'terms' => array( 'system' ), 'operator' => 'NOT IN' ), ), ) + $_aQueryArgs; break; case 'disabled': $_aQueryArgs = array( 'post_status' => array( 'pending', ), 'tax_query' => array( 'relation' => 'AND', array( 'taxonomy' => TaskScheduler_Registry::Taxonomy_SystemLabel, 'field' => 'slug', 'terms' => array( 'system' ), 'operator' => 'NOT IN' ), ), ) + $_aQueryArgs; break; case 'system': $_aQueryArgs = array( 'post_status' => array( 'pending', 'private', 'publish' ), 'tax_query' => array( array( 'taxonomy' => TaskScheduler_Registry::Taxonomy_SystemLabel, 'field' => 'slug', 'terms' => 'system', ), ), ) + $_aQueryArgs; break; case 'thread': return TaskScheduler_ThreadUtility::find( $_aQueryArgs ); } return TaskScheduler_TaskUtility::find( $_aQueryArgs ); } protected function _setTaskListingTableForm() { $this->addSettingSections( TaskScheduler_Registry::AdminPage_TaskList, array( 'section_id' => 'task_listing_table', ) ); $this->addSettingFields( 'task_listing_table', array( 'field_id' => 'check_actions_now', 'type' => 'submit', 'value' => __( 'Check Actions Now', 'task-scheduler' ), 'attributes' => array( 'field' => array( 'style' => 'float:right; clear:none; display: inline;', ), 'class' => 'button button-secondary', ), ) ); } public function submit_TaskScheduler_AdminPage_task_listing_table_check_actions_now() { do_action( 'task_scheduler_action_check_shceduled_actions' ); $this->setSettingNotice( __( 'Checking actions now.', 'task-scheduler' ), 'updated' ); } public function content_ts_task_list( $sHTML ) { return $this->_getHeartbeatStatus() . $this->_getTableOutput() . $sHTML; } private function _getHeartbeatStatus() { $_fIsAlive = TaskScheduler_Option::get( array( 'server_heartbeat', 'power' ) ) && TaskScheduler_ServerHeartbeat::isAlive(); $_sStatus = $_fIsAlive ? "<span class='running'>" . __( 'Running', 'task-scheduler' ) . "</span>" : "<span class='not-running'>" . __( 'Not Running', 'task-scheduler' ) . "</span>"; $_sLastCheckedTime = $_fIsAlive ? ' ' . __( 'The last checked time', 'task-scheduler' ) . ': ' . TaskScheduler_WPUtility::getSiteReadableDate( floor( TaskScheduler_ServerHeartbeat::getLastBeatTime() ), 'Y/m/d G:i:s', true ) : ''; $_sCurrentServerTime = __( 'The current server set time', 'task-scheduler' ) . ': ' . TaskScheduler_WPUtility::getSiteReadableDate( time(), 'Y/m/d G:i:s', true ); return "<p class='section-description'>" . sprintf( __( 'The background task monitoring routine is <strong>%1$s</strong>.', 'task-scheduler' ), $_sStatus ) . $_sLastCheckedTime . ' ' . $_sCurrentServerTime . "</p>"; } private function _getTableOutput() { $this->_oTaskListTable->prepare_items(); $_sNonce = $this->_oTaskListTable->setNonce(); ob_start(); $this->_oTaskListTable->views(); $this->_oTaskListTable->display(); echo "<input type='hidden' name='task_scheduler_task_table' value='1' />"; echo "<input type='hidden' name='task_scheduler_nonce' value='{$_sNonce}' />"; $_sContent = ob_get_contents(); ob_end_clean(); return $_sContent; } }abstract class TaskScheduler_AdminPage_Setup extends TaskScheduler_AdminPage_Form { public function setUp() { $this->_definePages(); $this->_defineStyles(); } private function _definePages() { $this->setRootMenuPage( __( 'Task Scheduler', 'task-scheduler' ), TaskScheduler_Registry::getPluginURL( '/asset/image/menu_icon_16x16.png' ) ); $this->addSubMenuItems( array( 'title' => __( 'Tasks', 'task-scheduler' ), 'page_slug' => TaskScheduler_Registry::AdminPage_TaskList ), array( 'title' => __( 'Test Page', 'task-scheduler' ), 'page_slug' => 'testing_page', ), array() ); } private function _defineStyles() { $this->setPageHeadingTabsVisibility( false ); $this->setPageTitleVisibility( true ); $this->enqueueStyle( TaskScheduler_Registry::getPluginURL( '/asset/css/ts_task_list.css' ) ); $this->setDisallowedQueryKeys( array( 'settings-notice', 'task_scheduler_nonce', 'action', 'transient_key', 'task_scheduler_task' ) ); $this->setPluginSettingsLinkLabel( '' ); } }final class TaskScheduler_AdminPage extends TaskScheduler_AdminPage_Setup { public function _replyToBuildMenu() { parent::_replyToBuildMenu(); $_sPageSlug = $this->oProp->aRootMenu['sPageSlug']; if ( ! isset( $GLOBALS['submenu'][ $_sPageSlug ] ) && ! is_array( $GLOBALS['submenu'][ $_sPageSlug ] ) ) { return; } $_iMenuPosition_Task = null; $_iMenuPosition_Log = null; foreach ( $GLOBALS['submenu'][ $_sPageSlug ] as $_iIndex => $_aSubMenu ) { if ( ! isset( $_aSubMenu[ 2 ] ) ) { continue; } if ( TaskScheduler_Registry::AdminPage_TaskList == $_aSubMenu[ 2 ] ) { $_iMenuPosition_Task = $_iIndex; } if ( 'edit.php?post_type=' . TaskScheduler_Registry::PostType_Log == $_aSubMenu[ 2 ] ) { $_iMenuPosition_Log = $_iIndex; } } if ( isset( $_iMenuPosition_Task, $_iMenuPosition_Log ) ) { TaskScheduler_WPUtility::swapElements( $GLOBALS['submenu'][ $_sPageSlug ], $_iMenuPosition_Task, $_iMenuPosition_Log ); } } }abstract class TaskScheduler_AdminPage_Setting_Start extends TaskScheduler_AdminPageFramework { public function setUp() {} protected function _defineForm() {} public function options_TaskScheduler_AdminPage_Setting( $aOptions ) { return $aOptions + TaskScheduler_Option::$aDefaults; } }abstract class TaskScheduler_AdminPage_Setting_Form_Reset extends TaskScheduler_AdminPage_Setting_Start { public function setUp() { $this->addInPageTabs( TaskScheduler_Registry::AdminPage_Setting, array( 'tab_slug' => 'reset', 'title' => __( 'Reset', 'task-scheduler' ), ) ); parent::setUp(); } protected function _defineForm() { $this->addSettingSections( TaskScheduler_Registry::AdminPage_Setting, array( 'section_id' => 'reset', 'tab_slug' => 'reset', 'title' => __( 'Reset', 'task-scheduler' ), ) ); $this->addSettingFields( 'reset', array( 'field_id' => 'reset_upon_deactivation', 'title' => __( 'Delete Options upon Deactivation', 'task-scheduler' ), 'type' => 'checkbox', 'label' => __( 'Deletes the settings when the plugin gets deactivated.', 'task-scheduler' ), ), array( 'field_id' => 'submit', 'type' => 'submit', 'label' => __( 'Save', 'task-scheduler' ), 'label_min_width' => 0, 'attributes' => array( 'field' => array( 'style' => 'float:right; clear:none; display: inline;', ), ), ), array( 'field_id' => 'reset', 'type' => 'submit', 'title' => __( 'Reset Options', 'task-scheduler' ), 'label' => __( 'Reset', 'task-scheduler' ), 'label_min_width' => 0, 'reset' => true, 'attributes' => array( 'field' => array( ), 'class' => 'button button-secondary', ), ) ); parent::_defineForm(); } }abstract class TaskScheduler_AdminPage_Setting_Form_Email extends TaskScheduler_AdminPage_Setting_Form_Reset { public function __setUp() { $this->addInPageTabs( TaskScheduler_Registry::AdminPage_Setting, array( 'tab_slug' => 'email', 'title' => __( 'Email', 'task-scheduler' ), ) ); parent::setUp(); } protected function __defineForm() { $this->addSettingSections( TaskScheduler_Registry::AdminPage_Setting, array( 'section_id' => 'email', 'tab_slug' => 'email', 'title' => __( 'Email', 'task-scheduler' ), ) ); $this->addSettingFields( 'email', array( 'field_id' => 'message_body', 'title' => __( 'Message Body', 'task-scheduler' ), 'type' => 'textarea', 'rich' => true, 'description' => __( 'Define what message should be sent.', 'task-scheduler' ), ), array( 'field_id' => 'submit', 'type' => 'submit', 'label' => __( 'Save', 'task-scheduler' ), 'label_min_width' => 0, 'attributes' => array( 'field' => array( 'style' => 'float:right; clear:none; display: inline;', ), ), ) ); parent::_defineForm(); } }abstract class TaskScheduler_AdminPage_Setting_Form_Task extends TaskScheduler_AdminPage_Setting_Form_Email { public function setUp() { $this->addInPageTabs( TaskScheduler_Registry::AdminPage_Setting, array( 'tab_slug' => 'task', 'title' => __( 'Task', 'task-scheduler' ), ) ); parent::setUp(); } protected function _defineForm() { $this->addSettingSections( TaskScheduler_Registry::AdminPage_Setting, array( 'section_id' => 'routine', 'tab_slug' => 'task', 'title' => __( 'Task', 'task-scheduler' ), 'description' => __( 'The general settings regarding task routines.', 'task-scheduler' ), ), array( 'section_id' => 'task_default', 'tab_slug' => 'task', 'title' => __( 'Default', 'task-scheduler' ), 'description' => __( 'The settings of individual tasks take precedence.', 'task-scheduler' ), ) ); $this->addSettingFields( 'routine', array( 'field_id' => 'max_background_routine_count', 'title' => __( 'Max Number of Background Routines', 'task-scheduler' ), 'type' => 'number', 'description' => __( 'The larger the number, the faster the tasks get completed but consume server resources.', 'task-scheduler' ), ) ); $this->addSettingFields( 'task_default', array( 'field_id' => 'max_root_log_count', 'title' => __( 'Max Count of Log Entries', 'task-scheduler' ), 'type' => 'number', 'description' => __( 'The default number of allowed max count of log items.', 'task-scheduler' ), 'attributes' => array( 'min' => 0, 'step' => 1, ), ), array( 'field_id' => 'max_execution_time', 'title' => __( 'Max Task Execution Time', 'task-scheduler' ), 'type' => 'number', 'after_label' => ' ' .__( 'second(s)', 'task-scheduler' ), 'description' => __( 'The default duration of the max task execution.', 'task-scheduler' ), 'attributes' => array( 'min' => 0, 'step' => 1, 'max' => TaskScheduler_WPUtility::canUseIniSet() ? null : TaskScheduler_WPUtility::getServerAllowedMaxExecutionTime( 30 ), ), ), array( 'field_id' => 'submit', 'type' => 'submit', 'label' => __( 'Save', 'task-scheduler' ), 'label_min_width' => 0, 'attributes' => array( 'field' => array( 'style' => 'float:right; clear:none; display: inline;', ), ), ) ); parent::_defineForm(); } }abstract class TaskScheduler_AdminPage_Setting_Form_Heartbeat extends TaskScheduler_AdminPage_Setting_Form_Task { public function setUp() { $this->addInPageTabs( TaskScheduler_Registry::AdminPage_Setting, array( 'tab_slug' => 'server_heartbeat', 'title' => __( 'Server Heartbeat', 'task-scheduler' ), ) ); parent::setUp(); } protected function _defineForm() { $this->addSettingSections( TaskScheduler_Registry::AdminPage_Setting, array( 'section_id' => 'server_heartbeat', 'tab_slug' => 'server_heartbeat', 'title' => __( 'Server Heartbeat', 'task-scheduler' ), ) ); $this->addSettingFields( 'server_heartbeat', array( 'field_id' => 'power', 'title' => __( 'Server Heartbeat', 'task-scheduler' ), 'type' => 'radio', 'default' => 1, 'label' => array( 1 => __( 'On', 'task-scheduler' ), 0 => __( 'Off', 'task-scheduler' ), ), 'description' => __( 'Decide whether the server checks the tasks in the background.', 'task-scheduler' ), ), array( 'field_id' => 'instruction', 'type' => 'text', 'if' => ! TaskScheduler_Option::get( array( 'server_heartbeat', 'power' ) ), 'attributes' => array( 'readonly' => 'ReadOnly', 'name' => '', 'size' => 60, ), 'value' => site_url( '/?task_scheduler_checking_actions=1' ), 'before_fieldset' => '<p class="warning">' . '* ' . __( 'Set up a Cron job that accesses the following url to check scheduled actions.', 'task-scheduler' ) . '</p>', ), array( 'field_id' => 'status', 'title' => __( 'Status', 'task-scheduler' ), 'type' => 'text', 'attributes' => array( 'readonly' => 'ReadOnly', 'name' => '', ), array(), ), array( 'field_id' => 'interval', 'title' => __( 'Interval', 'task-scheduler' ), 'type' => 'number', 'after_label' => ' ' . __( 'second(s)', 'task-scheduler' ), 'description' => __( 'Set the interval in seconds that the plugin checks the tasks in the background.', 'task-scheduler' ) . ' ' . __( 'This may not take effect if the server has a restriction on PHP\'s maximum execution time and the <code>ini_set()</code> function.' ), 'attributes' => array( 'min' => 0, 'step' => 1, 'max' => TaskScheduler_WPUtility::canUseIniSet() ? null : TaskScheduler_WPUtility::getServerAllowedMaxExecutionTime( 24 ), ), ), array( 'field_id' => 'query_string', 'title' => __( 'URL', 'task-scheduler' ), 'type' => 'checkbox', 'default' => true, 'label' => __( 'Show the query string in the request URL of the background page-load to indicate the server heartbeat.', 'task-scheduler' ), array( 'type' => 'text', 'label' => __( 'Key', 'task-scheduler' ), 'default' => 'doing_server_heartbeat', ), ), array( 'field_id' => 'submit', 'type' => 'submit', 'label' => __( 'Save', 'task-scheduler' ), 'label_min_width' => 0, 'attributes' => array( 'field' => array( 'style' => 'float:right; clear:none; display: inline;', ), ), ) ); parent::_defineForm(); } public function field_definition_TaskScheduler_AdminPage_Setting_server_heartbeat_status( $aField ) { $aField['before_label'] = "<span class='description-label'>" . __( 'Last Beat Time', 'task-scheduler' ) . ":</span>"; $aField[ 0 ]['before_label'] = "<span class='description-label'>" . __( 'Next Check', 'task-scheduler' ) . ":</span>"; $_sLastBeatTime = TaskScheduler_WPUtility::getSiteReadableDate( TaskScheduler_ServerHeartbeat::getLastBeatTime(), get_option( 'date_format' ) . ' G:i:s', true ); $aField['value'] = $_sLastBeatTime; $aField[ 0 ]['value'] = TaskScheduler_WPUtility::getSiteReadableDate( TaskScheduler_ServerHeartbeat::getNextCheckTime(), get_option( 'date_format' ) . ' G:i:s', true ); return $aField; } public function validation_TaskScheduler_AdminPage_Setting_server_heartbeat( $aInput, $aOldInput, $oAdminPage ) { if ( isset( $aInput['query_string'][ 1 ] ) ) { $aInput['query_string'][ 1 ] = TaskScheduler_WPUtility::sanitizeCharsForURLQueryKey( $aInput['query_string'][ 1 ] ); } if ( isset( $aInput['power'], $aInput['interval'] ) && $aInput['power'] && $aInput['interval'] ) { $_sTargetURL = $aInput['query_string'][ 0 ] && $aInput['query_string'][ 1 ] ? add_query_arg( array( $aInput['query_string'][ 1 ] => microtime( true ), ), site_url() ) : site_url(); TaskScheduler_ServerHeartbeat::run( array( 'target_url' => $_sTargetURL, 'interval' => $aInput['interval'] ) ); } if ( isset( $aInput['power'], $aInput['interval'] ) && ( ! $aInput['power'] || ! $aInput['interval'] ) ) { TaskScheduler_ServerHeartbeat::stop(); } return $aInput; } }final class TaskScheduler_AdminPage_Setting extends TaskScheduler_AdminPage_Setting_Form_Heartbeat { public function setUp() { $this->setRootMenuPageBySlug( TaskScheduler_Registry::AdminPage_Root ); $this->addSubMenuItems( array( 'title' => __( 'Settings', 'task-scheduler' ), 'page_slug' => TaskScheduler_Registry::AdminPage_Setting ) ); $this->_defineStyles(); add_action( "load_" . TaskScheduler_Registry::AdminPage_Setting, array( $this, '_replyToLoadSettingPage' ) ); parent::setUp(); } public function _replyToLoadSettingPage( $oAdminPage ) { $this->_defineForm(); } protected function _defineStyles() { $this->setPageHeadingTabsVisibility( false ); $this->setInPageTabsVisibility( true ); $this->setPageTitleVisibility( false ); $this->setInPageTabTag( 'h2' ); $this->enqueueStyle( TaskScheduler_Registry::getPluginURL( '/asset/css/admin_settings.css' ) ); $this->setDisallowedQueryKeys( 'settings-notice' ); $this->setDisallowedQueryKeys( 'transient_key' ); } }abstract class TaskScheduler_AdminPage_System_Start extends TaskScheduler_AdminPageFramework { }abstract class TaskScheduler_AdminPage_System_Form extends TaskScheduler_AdminPage_System_Start { protected function _setSystemForm() { $this->addSettingSections( TaskScheduler_Registry::AdminPage_System, array( 'section_id' => 'system', 'title' => __( 'System', 'task-scheduler' ), ) ); $this->addSettingFields( 'system', array( 'field_id' => 'site_system_information', 'title' => __( 'Site System Information', 'task-scheduler' ), 'type' => 'system', 'default' => 25, ), array( 'field_id' => 'submit', 'type' => 'submit', 'label' => __( 'Save', 'task-scheduler' ), 'label_min_width' => 0, 'attributes' => array( 'field' => array( 'style' => 'float:right; clear:none; display: inline;', ), ), ) ); } }final class TaskScheduler_AdminPage_System extends TaskScheduler_AdminPage_System_Form { public function setUp() { $this->setRootMenuPageBySlug( TaskScheduler_Registry::AdminPage_Root ); $this->addSubMenuItems( array( 'title' => __( 'System', 'task-scheduler' ), 'page_slug' => TaskScheduler_Registry::AdminPage_System ) ); $this->_setSystemForm(); $this->setPluginSettingsLinkLabel( '' ); } }abstract class TaskScheduler_AdminPage_Wizard_Start extends TaskScheduler_AdminPageFramework { public function start() { $this->_disableAddNewButton(); } private function _disableAddNewButton() { if ( ! $this->oProp->bIsAdmin ) { return; } if ( ! in_array( $this->oUtil->getPageNow(), array( 'post-new.php' ) ) ) { return; } if ( $this->oUtil->getCurrentPostType() != TaskScheduler_Registry::PostType_Task ) { return; } TaskScheduler_PluginUtility::goToAddNewPage(); } }abstract class TaskScheduler_AdminPage_Wizard_Validation extends TaskScheduler_AdminPage_Wizard_Start { public function validation_TaskScheduler_AdminPage_Wizard( $aInput, $aOldInput, $oAdminPage ) { $_aWizardOptions = isset( $aInput[ '_wizard_options' ] ) ? $aInput[ '_wizard_options' ] : array(); if ( ! isset( $_aWizardOptions['post_title'] ) || ! $_aWizardOptions['post_title'] ) { $this->setSettingNotice( __( 'The wizard session has been expired. Please start from the beginning.', 'task-scheduler' ) ); die( TaskScheduler_PluginUtility::goToAddNewPage() ); } $_aSavedValues = $this->_saveValidatedWizardOptions( $_aWizardOptions ); return array( 'dummy value' ); } protected function _saveValidatedWizardOptions( array $aWizardOptions ) { if ( ! isset( $_GET['transient_key'] ) ) { return; } $aWizardOptions = apply_filters( 'task_scheduler_admin_filter_saving_wizard_options', $aWizardOptions ); set_transient( $_GET['transient_key'], $aWizardOptions, 30*60 ); return $aWizardOptions; } }abstract class TaskScheduler_AdminPage_Wizard_Tab_Wizard extends TaskScheduler_AdminPage_Wizard_Validation { protected function _setWizard( $sTransientKey ) { $this->addSettingSections( TaskScheduler_Registry::AdminPage_AddNew, array( 'tab_slug' => 'wizard', 'section_id' => 'wizard', 'title' => __( 'Task Creation Wizard', 'task-scheduler' ), ) ); $this->addSettingFields( 'wizard', array( 'field_id' => 'transient_key', 'type' => 'text', 'hidden' => true, 'value' => $sTransientKey, ), array( 'field_id' => 'post_title', 'title' => __( 'Task Name', 'task-scheduler' ), 'type' => 'text', ), array( 'field_id' => 'post_excerpt', 'title' => __( 'Description', 'task-scheduler' ) . ' (' . __( 'optional', 'task-manager' ) . ')', 'type' => 'textarea', ), array( 'field_id' => 'occurrence', 'title' => __( 'Occurrence', 'task-scheduler' ), 'type' => 'radio', 'label_min_width' => '100%', 'label' => array(), ), array( 'field_id' => 'submit', 'type' => 'submit', 'label' => __( 'Next', 'task-scheduler' ), 'label_min_width' => 0, 'attributes' => array( 'field' => array( 'style' => 'float:right; clear:none; display: inline;', ), ), ) ); } public function field_definition_TaskScheduler_AdminPage_Wizard_wizard_occurrence( $aField ) { $aField['label'] = apply_filters( 'task_scheduler_admin_filter_field_labels_wizard_occurrence', $aField['label'] ); foreach( $aField['label'] as $_sSlug => $_sLabel ) { $_sDescription = apply_filters( "task_scheduler_filter_description_occurrence_{$_sSlug}", '' ); if ( $_sDescription ) { $aField['label'][ $_sSlug ] = $_sLabel . ' - ' . "<span class='description'>" . $_sDescription . "</span>"; } } $_aLabels = array_keys( $aField['label'] ); $aField['default'] = array_shift( $_aLabels ); return $aField; } public function validation_TaskScheduler_AdminPage_Wizard_wizard( $aInput, $aOldInput ) { $_bIsValid = true; $_aErrors = array(); if ( ! $aInput['post_title'] ) { $_aErrors['wizard']['post_title'] = __( 'A task name must be set.', 'task-scheduler' ); $_bIsValid = false; } if ( ! $aInput['occurrence'] ) { $_aErrors['wizard']['occurrence'] = __( 'At least one item must be selected.', 'task-scheduler' ); $_bIsValid = false; } if ( ! $_bIsValid ) { $this->setFieldErrors( $_aErrors ); $this->setSettingNotice( __( 'Please try again.', 'task-scheduler' ) ); return $aOldInput; } $_sRedirectURL = add_query_arg( array( 'transient_key' => $aInput['transient_key'], )); $_sRedirectURL = add_query_arg( array( 'transient_key' => $aInput['transient_key'], ), apply_filters( 'task_scheduler_admin_filter_wizard_occurrence_redirect_url_' . $aInput['occurrence'], $_sRedirectURL, $aInput ) ); $_sPreviousURLKey = remove_query_arg( array( 'transient_key', 'settings-notice', 'settings-updated' ), $_sRedirectURL ); $aInput['previous_urls'] = $this->_getWizardOptions( 'previous_urls' ); $aInput['previous_urls'] = is_array( $aInput['previous_urls'] ) ? $aInput['previous_urls'] : array(); $aInput['previous_urls'][ $_sPreviousURLKey ] = add_query_arg( array( 'transient_key' => $aInput['transient_key'], ) ); $aInput['occurrence_label'] = apply_filters( "task_scheduler_filter_label_occurrence_" . $aInput['occurrence'], $aInput['occurrence'] ); $this->_saveWizardOptions( $aInput['transient_key'], $aInput ); exit( wp_safe_redirect( $_sRedirectURL ) ); } }abstract class TaskScheduler_AdminPage_Wizard_Tab_SelectAction extends TaskScheduler_AdminPage_Wizard_Tab_Wizard { protected function _setWizard_SelectAction( $sTransientKey ) { $this->addSettingSections( TaskScheduler_Registry::AdminPage_AddNew, array( 'tab_slug' => 'wizard_select_action', 'section_id' => 'wizard_select_action', 'title' => __( 'Select Action', 'task-scheduler' ), ) ); $this->addSettingFields( 'wizard_select_action', array( 'field_id' => 'transient_key', 'type' => 'hidden', 'hidden' => true, 'value' => $sTransientKey, ), array( 'field_id' => 'routine_action', 'title' => __( 'Action', 'task-scheduler' ), 'type' => 'revealer', 'label' => array(), ), array( 'field_id' => 'custom_action', 'title' => __( 'Custom Action', 'task-scheduler' ), 'type' => 'text', 'description' => __( 'If none of the action you want to execute is listed above, specify the action name here.', 'task-scheduler' ), ), array( 'field_id' => 'argument', 'title' => __( 'Argument', 'task-scheduler' ) . ' (' . __( 'optional', 'task-scheduler' ) . ')', 'type' => 'text', 'repeatable' => true, 'description' => __( 'Set the arguments passed to the action.', 'task-scheduler' ), ), array( 'field_id' => 'submit', 'type' => 'submit', 'label' => __( 'Next', 'task-scheduler' ), 'value' => __( 'Next', 'task-scheduler' ), 'label_min_width' => 0, 'attributes' => array( 'field' => array( 'style' => 'float:right; clear:none; display: inline;', ), ), ) ); } public function field_definition_TaskScheduler_AdminPage_Wizard_wizard_select_action_routine_action( $aField ) { return $this->_getRoutineActionField( $aField ); } protected function _getRoutineActionField( array $aField ) { $_sRoutineActionSlug = $this->_getWizardOptions( 'routine_action' ); $aField['label'] = apply_filters( 'task_scheduler_admin_filter_field_labels_wizard_action', array() ); $aField['value'] = array_key_exists ( $_sRoutineActionSlug, $aField['label'] ) ? "#description-{$_sRoutineActionSlug}" : -1; $_aLabels = array( -1 => '--- ' . __( 'Select Action', 'task-scheduler' ) . ' ---', ); $_aDescriptions = array(); foreach( $aField['label'] as $_sSlug => $_sLabel ) { $_aLabels[ "#description-{$_sSlug}" ] = $_sLabel; $_sDescription = apply_filters( "task_scheduler_filter_description_action_{$_sSlug}", '' ); if ( ! $_sDescription ) { continue; } $_sDisplay = $_sSlug === $_sRoutineActionSlug ? '' : 'display:none;'; $_aDescriptions[] = "<p id='description-{$_sSlug}' style='{$_sDisplay}'>" . $_sDescription . "</p>"; } $aField['label'] = $_aLabels; $aField['after_fieldset'] = implode( PHP_EOL, $_aDescriptions ); return $aField; } public function field_definition_TaskScheduler_AdminPage_Wizard_wizard_select_action_custom_action( $aField ) { $_sRoutineActionSlug = $this->_getWizardOptions( 'routine_action' ); if ( ! array_key_exists ( $_sRoutineActionSlug, apply_filters( 'task_scheduler_admin_filter_field_labels_wizard_action', array( -1 => '_dummy_value' ) ) ) ) { $aField['value'] = $_sRoutineActionSlug; } return $aField; } public function field_definition_TaskScheduler_AdminPage_Wizard_wizard_select_action_submit( $aField ) { $_aPreviousUrls = $this->_getWizardOptions( 'previous_urls' ); $_sCurrentURLKey = remove_query_arg( array( 'transient_key', 'settings-notice', 'settings-updated' ) ); $aField[ 0 ] = array( 'value' => __( 'Back', 'task-scheduler' ), 'href' => isset( $_aPreviousUrls[ $_sCurrentURLKey ] ) ? $_aPreviousUrls[ $_sCurrentURLKey ] : '', 'attributes' => array( 'class' => 'button secondary ', ), ); return $aField; } public function validation_TaskScheduler_AdminPage_Wizard_wizard_select_action( $aInput, $aOldInput ) { $_bIsValid = true; $_aErrors = array(); if ( '-1' === ( string ) $aInput['routine_action'] && '' == trim( $aInput['custom_action'] ) ) { $_aErrors['wizard_select_action'] = __( 'At least an action must be set.', 'task-scheduler' ); $_bIsValid = false; } if ( '-1' !== ( string ) $aInput['routine_action'] && trim( $aInput['custom_action'] ) ) { $_aErrors['wizard_select_action'] = __( 'Only one action can be set.', 'task-scheduler' ); $_bIsValid = false; unset( $aInput['custom_action'] ); } $aInput['argument'] = array_values( $aInput['argument'] ); if ( ! $_bIsValid ) { $this->setFieldErrors( $_aErrors ); $this->setSettingNotice( __( 'Please try again.', 'task-scheduler' ) ); $this->_saveWizardOptions( $aInput['transient_key'], $aInput ); return array(); } if ( ! $this->_getWizardOptions( 'post_title' ) ) { $this->setSettingNotice( __( 'The wizard session has been expired. Please start from the beginning.', 'task-scheduler' ) ); exit( TaskScheduler_PluginUtility::goToAddNewPage() ); } $aInput['routine_action'] = '-1' !== ( string ) $aInput['routine_action'] ? $aInput['routine_action'] : $aInput['custom_action']; $aInput['routine_action'] = preg_replace( '/^#description-/', '', $aInput['routine_action'] ); $_aWizardOptions = $aInput; $_aWizardOptions['action_label'] = apply_filters( "task_scheduler_filter_label_action_" . $aInput['routine_action'], $aInput['routine_action'] ); $_sNextPageURL = $this->_getNextPageURL( $_aWizardOptions ); $_sNextURLURLKey = remove_query_arg( array( 'transient_key', 'settings-notice', 'settings-updated' ), $_sNextPageURL ); $_aWizardOptions['previous_urls'] = $this->_getWizardOptions( 'previous_urls' ); $_aWizardOptions['previous_urls'] = is_array( $_aWizardOptions['previous_urls'] ) ? $_aWizardOptions['previous_urls'] : array(); $_aWizardOptions['previous_urls'][ $_sNextURLURLKey ] = add_query_arg( array( 'transient_key' => $aInput['transient_key'], ) ); $this->_saveWizardOptions( $_aWizardOptions['transient_key'], $_aWizardOptions ); exit( wp_safe_redirect( $_sNextPageURL ) ); } private function _getNextPageURL( array $aWizardOptions ) { $_sActionHook = $aWizardOptions['routine_action']; $_sRedirectURL = add_query_arg( array( 'transient_key' => $aWizardOptions['transient_key'], 'tab' => 'wizard_create_task', ) ); $_sRedirectURL = add_query_arg( array( 'transient_key' => $aWizardOptions['transient_key'], ), apply_filters( "task_scheduler_admin_filter_wizard_action_redirect_url_{$_sActionHook}", $_sRedirectURL, $aWizardOptions ) ); return $_sRedirectURL; } }abstract class TaskScheduler_AdminPage_Wizard_Tab_CreateTask extends TaskScheduler_AdminPage_Wizard_Tab_SelectAction { public function load_ts_add_new_wizard_create_task() { $_aWizardOptions = $this->_getWizardOptions(); $this->_deleteWizardOptions(); if ( ! isset( $_aWizardOptions['post_title'], $_aWizardOptions['occurrence'], $_aWizardOptions['routine_action'] ) ) { $this->setSettingNotice( __( 'The wizard session has been expired. Please start from the beginning.', 'task-scheduler' ) ); exit( TaskScheduler_PluginUtility::goToAddNewPage() ); } $_aWizardOptions = $this->_dropUnnecessaryWizardOptions( $_aWizardOptions ); $_aWizardOptions['_max_root_log_count'] = TaskScheduler_Option::get( array( 'task_default', 'max_root_log_count' ) ); $_aWizardOptions['_max_execution_time'] = TaskScheduler_Option::get( array( 'task_default', 'max_execution_time' ) ); $_aWizardOptions['_force_execution'] = false; $_iPostID = TaskScheduler_TaskUtility::add( $_aWizardOptions ); if ( $_iPostID ) { $_oTask = TaskScheduler_Routine::getInstance( $_iPostID ); $_oTask->setNextRunTime(); do_action( 'task_scheduler_action_check_shceduled_actions' ); $this->setSettingNotice( __( 'A task has been created.', 'task-scheduler' ), 'updated' ); } exit( TaskScheduler_PluginUtility::goToTaskListingPage() ); } protected function _dropUnnecessaryWizardOptions( array $aWizardOptions ) { unset( $aWizardOptions['submit'], $aWizardOptions['transient_key'], $aWizardOptions['previous_urls'], $aWizardOptions['action_label'], $aWizardOptions['occurrence_label'], $aWizardOptions['excerpt'] ); $_sMainActionSlug = $aWizardOptions['routine_action']; $_aSectionSlugs = apply_filters( "task_scheduler_admin_filter_wizard_slugs_{$_sMainActionSlug}", array() ); foreach( $_aSectionSlugs as $_sSectionSlug ) { if ( $_sSectionSlug === $_sMainActionSlug ) { continue; } unset( $aWizardOptions[ $_sSectionSlug ] ); } $_aOccurrenceSlugs = apply_filters( 'task_scheduler_admin_filter_field_labels_wizard_occurrence', array() ); $_aOccurrenceSlugs = array_keys( $_aOccurrenceSlugs ); foreach( $_aOccurrenceSlugs as $_sOccurrenceSlug ) { if ( $_sOccurrenceSlug === $aWizardOptions['occurrence'] ) { continue; } unset( $aWizardOptions[ $_sOccurrenceSlug ] ); } $_aActionSlugs = apply_filters( 'task_scheduler_admin_filter_field_labels_wizard_action', array() ); $_aActionSlugs = array_keys( $_aActionSlugs ); foreach( $_aActionSlugs as $_sActionSlug ) { if ( $_sActionSlug === $aWizardOptions['routine_action'] ) { continue; } unset( $aWizardOptions[ $_sActionSlug ] ); } return $aWizardOptions; } }abstract class TaskScheduler_AdminPage_Wizard_Setup extends TaskScheduler_AdminPage_Wizard_Tab_CreateTask { public function setUp() { $this->setRootMenuPageBySlug( TaskScheduler_Registry::AdminPage_Root ); $this->addSubMenuItems( array( 'title' => __( 'Add New Task', 'task-scheduler' ), 'page_slug' => TaskScheduler_Registry::AdminPage_AddNew, ) ); $this->addInPageTabs( TaskScheduler_Registry::AdminPage_AddNew, array( 'tab_slug' => 'wizard', 'title' => __( 'Wizard', 'task-scheduler' ), 'order' => 1, 'show_in_page_tab' => false, ), array( 'tab_slug' => 'wizard_select_action', 'title' => __( 'Select Action', 'task-scheduler' ), 'show_in_page_tab' => false, ), array( 'tab_slug' => 'wizard_create_task', 'title' => __( 'Create Task', 'task-scheduler' ), 'show_in_page_tab' => false, ) ); $this->_defineStyles(); $this->_sTransientKey = isset( $_GET['transient_key'] ) && $_GET['transient_key'] ? $_GET['transient_key'] : TaskScheduler_Registry::TransientPrefix . uniqid(); add_action( "load_" . TaskScheduler_Registry::AdminPage_AddNew, array( $this, '_replyToDefineForms' ) ); } public function _replyToDefineForms( $oAdminPage ) { $this->_registerCustomFieldTypes(); $this->_setWizard( $this->_sTransientKey ); $this->_setWizard_SelectAction( $this->_sTransientKey ); } protected function _registerCustomFieldTypes() { if ( ! $this->oProp->bIsAdmin ) { return; } $_sClassName = get_class( $this ); new TaskScheduler_DateTimeCustomFieldType( $_sClassName ); new TaskScheduler_TimeCustomFieldType( $_sClassName ); new TaskScheduler_DateCustomFieldType( $_sClassName ); new TaskScheduler_AutoCompleteCustomFieldType( $_sClassName ); new TaskScheduler_RevealerCustomFieldType( $_sClassName ); } protected function _defineStyles() { $this->setPageHeadingTabsVisibility( false ); $this->setInPageTabsVisibility( false ); $this->setInPageTabTag( 'h2' ); $this->enqueueStyle( TaskScheduler_Registry::getPluginURL( '/asset/css/admin_wizard.css' ) ); $this->setDisallowedQueryKeys( 'settings-notice' ); $this->setDisallowedQueryKeys( 'transient_key' ); $this->setPluginSettingsLinkLabel( '' ); } }class TaskScheduler_AdminPage_Wizard extends TaskScheduler_AdminPage_Wizard_Setup { public function start() { parent::start(); add_filter( 'task_scheduler_admin_filter_get_wizard_options', array( $this, '_replyToGetWizardOptions' ), 10, 2 ); } public function options_TaskScheduler_AdminPage_Wizard( $aOptions ) { $_aOptions = apply_filters( 'task_scheduler_admin_filter_wizard_options', $this->_getWizardOptions() ); return array( 'wizard' => $_aOptions, 'wizard_select_action' => $_aOptions, '_wizard_options' => $_aOptions, ); } protected function _saveWizardOptions( $sTransientKey, array $aMergingOptions ) { $_aStoredOptions = get_transient( $sTransientKey ); $_aStoredOptions = $_aStoredOptions ? $_aStoredOptions : array(); $_aSavingOptions = $aMergingOptions + $_aStoredOptions; $_aSavingOptions = array_filter( $_aSavingOptions ); unset( $_aSavingOptions['submit'] ); set_transient( $sTransientKey, $_aSavingOptions, 30*60 ); return $_aSavingOptions; } protected function _getWizardOptions( $sKey='' ) { static $_aWizardOptions; $_sTransientKey = isset( $_GET['transient_key'] ) ? $_GET['transient_key'] : ''; $_aWizardOptions = isset( $_aWizardOptions ) && false !== $_aWizardOptions ? $_aWizardOptions : get_transient( $_sTransientKey ); if ( empty( $sKey ) ) { return is_array( $_aWizardOptions ) ? $_aWizardOptions : array(); } return isset( $_aWizardOptions[ $sKey ] ) ? $_aWizardOptions[ $sKey ] : null; } protected function _deleteWizardOptions( $sTransientKey='' ) { $sTransientKey = $sTransientKey ? $sTransientKey : ( isset( $_GET['transient_key'] ) ? $_GET['transient_key'] : '' ); delete_transient( $sTransientKey ); } public function _replyToGetWizardOptions( $vDefault, $sKey='' ) { $_vReturn = $this->_getWizardOptions( $sKey ); if ( is_null( $_vReturn ) ) { return $vDefault; } if ( empty( $sKey ) && is_array( $_vReturn ) && empty( $_vReturn ) ) { return $vDefault; } return $_vReturn; } }abstract class TaskScheduler_AdminPage_EditModule_Start extends TaskScheduler_AdminPage_Wizard { public function start() { } public function setUp() {} protected function _defineForm() {} }abstract class TaskScheduler_AdminPage_EditModule_Validation extends TaskScheduler_AdminPage_EditModule_Start { public function validation_TaskScheduler_AdminPage_EditModule( $aInput, $aOldInput, $oAdminPage ) { $_aWizardOptions = isset( $aInput[ '_wizard_options' ] ) ? $aInput[ '_wizard_options' ] : array(); if ( ! empty( $_aWizardOptions ) ) { $_aSavedValues = $this->_saveValidatedWizardOptions( $_aWizardOptions ); } return array( 'dummy value' ); } }abstract class TaskScheduler_AdminPage_EditModule_Tab_UpdateModule extends TaskScheduler_AdminPage_EditModule_Validation { public function setUp() { $this->addInPageTabs( TaskScheduler_Registry::AdminPage_EditModule, array( 'tab_slug' => 'update_module', 'title' => __( 'Update Module Options', 'task-scheduler' ), 'show_in_page_tab' => false, ) ); parent::setUp(); add_action( "load_" . TaskScheduler_Registry::AdminPage_EditModule . "_update_module", array( $this, '_replyToLoadTab' ) ); } public function _replyToLoadTab( $oAdminPage ) { $_aWizardOptions = $this->_getWizardOptions(); $this->_deleteWizardOptions(); if ( ! isset( $_GET['post'] ) ) { $this->setSettingNotice( __( 'The wizard session has been expired. Please start from the beginning.', 'task-scheduler' ) ); exit( TaskScheduler_PluginUtility::goToEditTaskPage() ); } $_bUpdateSchedule = isset( $_aWizardOptions['_update_next_schedule'] ) ? $_aWizardOptions['_update_next_schedule'] : false; $_aWizardOptions = $this->_dropUnnecessaryWizardOptions( $_aWizardOptions ); TaskScheduler_WPUtility::updatePostMeta( $_GET['post'], $_aWizardOptions ); if ( $_bUpdateSchedule ) { $_oTask = TaskScheduler_Routine::getInstance( $_GET['post'] ); $_oTask->deleteMeta( '_last_run_time' ); $_oTask->setNextRunTime(); } $this->setSettingNotice( __( 'The task has been updated.', 'task-scheduler' ), 'updated' ); exit( TaskScheduler_PluginUtility::goToEditTaskPage() ); } protected function _dropUnnecessaryWizardOptions( array $aWizardOptions ) { unset( $aWizardOptions['_edit_lock'], $aWizardOptions['_edit_last'], $aWizardOptions['_update_next_schedule'] ); return parent::_dropUnnecessaryWizardOptions( $aWizardOptions ); } }abstract class TaskScheduler_AdminPage_EditModule_Tab_Action extends TaskScheduler_AdminPage_EditModule_Tab_UpdateModule { public function setUp() { $this->addInPageTabs( TaskScheduler_Registry::AdminPage_EditModule, array( 'tab_slug' => 'edit_action', 'title' => __( 'Edit Action', 'task-scheduler' ), 'show_in_page_tab' => false, ) ); parent::setUp(); } protected function _defineForm() { $this->addSettingSections( TaskScheduler_Registry::AdminPage_EditModule, array( 'section_id' => 'edit_action', 'tab_slug' => 'edit_action', 'title' => __( 'Action', 'task-scheduler' ), ) ); $this->addSettingFields( 'edit_action', array( 'field_id' => 'transient_key', 'type' => 'text', 'hidden' => true, 'value' => $this->_sTransientKey, ), array( 'field_id' => 'routine_action', 'title' => __( 'Action', 'task-scheduler' ), 'type' => 'revealer', 'label' => array(), ), array( 'field_id' => 'custom_action', 'title' => __( 'Custom Action', 'task-scheduler' ), 'type' => 'text', 'description' => __( 'If none of the action you want to execute is listed above, specify the action name here.', 'task-scheduler' ), ), array( 'field_id' => 'submit', 'type' => 'submit', 'label' => __( 'Next', 'task-scheduler' ), 'label_min_width' => 0, 'attributes' => array( 'field' => array( 'style' => 'float:right; clear:none; display: inline;', ), ), array( 'value' => __( 'Back', 'task-scheduler' ), 'href' => TaskScheduler_PluginUtility::getEditTaskPageURL(), 'attributes' => array( 'class' => 'button secondary ', ), ), ) ); parent::_defineForm(); } public function field_definition_TaskScheduler_AdminPage_EditModule_edit_action_routine_action( $aField ) { return $this->_getRoutineActionField( $aField ); $_sRoutineActionSlug = $this->_getWizardOptions( 'routine_action' ); $aField['label'] = apply_filters( 'task_scheduler_admin_filter_field_labels_wizard_action', array( -1 => '--- ' . __( 'Select Action', 'task-scheduler' ) . ' ---', ) ); if ( ! array_key_exists ( $_sRoutineActionSlug, $aField['label'] ) ) { $aField['value'] = -1; } return $aField; } public function field_definition_TaskScheduler_AdminPage_EditModule_edit_action_custom_action( $aField ) { $_sRoutineActionSlug = $this->_getWizardOptions( 'routine_action' ); if ( ! array_key_exists ( $_sRoutineActionSlug, apply_filters( 'task_scheduler_admin_filter_field_labels_wizard_action', array( -1 => '_dummy_value' ) ) ) ) { $aField['value'] = $_sRoutineActionSlug; } return $aField; } public function validation_TaskScheduler_AdminPage_EditModule_edit_action( $aInput, $aOldInput ) { $_bIsValid = true; $_aErrors = array(); if ( '-1' === ( string ) $aInput['routine_action'] && '' == trim( $aInput['custom_action'] ) ) { $_aErrors['edit_action'] = __( 'At least an action must be set.', 'task-scheduler' ); $_bIsValid = false; } if ( '-1' !== ( string ) $aInput['routine_action'] && trim( $aInput['custom_action'] ) ) { $_aErrors['edit_action'] = __( 'Only one action can be set.', 'task-scheduler' ); $_bIsValid = false; unset( $aInput['custom_action'] ); } if ( ! $_bIsValid ) { $this->setFieldErrors( $_aErrors ); $this->setSettingNotice( __( 'Please try again.', 'task-scheduler' ) ); $this->_saveWizardOptions( $aInput['transient_key'], $aInput ); return array(); } $aInput['routine_action'] = '-1' !== ( string ) $aInput['routine_action'] ? $aInput['routine_action'] : $aInput['custom_action']; $aInput['routine_action'] = preg_replace( '/^#description-/', '', $aInput['routine_action'] ); $_aWizardOptions = $aInput; $_aWizardOptions['action_label'] = apply_filters( "task_scheduler_filter_label_action_" . $aInput['routine_action'], $aInput['routine_action'] ); $_sNextPageURL = $this->_getNextPageURL( $_aWizardOptions ); $_sNextURLURLKey = remove_query_arg( array( 'transient_key', 'settings-notice', 'settings-updated' ), $_sNextPageURL ); $_aWizardOptions['previous_urls'] = $this->_getWizardOptions( 'previous_urls' ); $_aWizardOptions['previous_urls'] = is_array( $_aWizardOptions['previous_urls'] ) ? $_aWizardOptions['previous_urls'] : array(); $_aWizardOptions['previous_urls'][ $_sNextURLURLKey ] = add_query_arg( array( 'transient_key' => $aInput['transient_key'], ) ); $_aSavedValue = $this->_saveWizardOptions( $_aWizardOptions['transient_key'], $_aWizardOptions ); exit( wp_safe_redirect( $_sNextPageURL ) ); } private function _getNextPageURL( array $aWizardOptions ) { $_sActionHook = $aWizardOptions['routine_action']; $_sRedirectURL = add_query_arg( array( 'transient_key' => $aWizardOptions['transient_key'], 'tab' => 'update_module', ) ); $_sRedirectURL = add_query_arg( array( 'transient_key' => $aWizardOptions['transient_key'], ), apply_filters( "task_scheduler_admin_filter_wizard_action_redirect_url_{$_sActionHook}", $_sRedirectURL, $aWizardOptions ) ); return $_sRedirectURL; } }abstract class TaskScheduler_AdminPage_EditModule_Tab_Occurrence extends TaskScheduler_AdminPage_EditModule_Tab_Action { public function setUp() { $this->addInPageTabs( TaskScheduler_Registry::AdminPage_EditModule, array( 'tab_slug' => 'edit_occurrence', 'title' => __( 'Edit Occurrence', 'task-scheduler' ), 'order' => 1, 'show_in_page_tab' => false, ) ); parent::setUp(); } protected function _defineForm() { $this->addSettingSections( TaskScheduler_Registry::AdminPage_EditModule, array( 'section_id' => 'edit_occurrence', 'tab_slug' => 'edit_occurrence', 'title' => __( 'Occurrence', 'task-scheduler' ), ) ); $this->addSettingFields( 'edit_occurrence', array( 'field_id' => 'transient_key', 'type' => 'text', 'hidden' => true, 'value' => $this->_sTransientKey, ), array( 'field_id' => 'occurrence', 'title' => __( 'Occurrence', 'task-scheduler' ), 'type' => 'radio', 'label_min_width' => '100%', 'label' => array(), ), array( 'field_id' => 'submit', 'type' => 'submit', 'label' => __( 'Next', 'task-scheduler' ), 'label_min_width' => 0, 'attributes' => array( 'field' => array( 'style' => 'float:right; clear:none; display: inline;', ), ), array( 'value' => __( 'Back', 'task-scheduler' ), 'href' => TaskScheduler_PluginUtility::getEditTaskPageURL(), 'attributes' => array( 'class' => 'button secondary ', ), ), ) ); parent::_defineForm(); } public function field_definition_TaskScheduler_AdminPage_EditModule_edit_occurrence_occurrence( $aField ) { $aField['label'] = apply_filters( 'task_scheduler_admin_filter_field_labels_wizard_occurrence', $aField['label'] ); foreach( $aField['label'] as $_sSlug => $_sLabel ) { $_sDescription = apply_filters( "task_scheduler_filter_description_occurrence_{$_sSlug}", '' ); if ( $_sDescription ) { $aField['label'][ $_sSlug ] = $_sLabel . ' - ' . "<span class='description'>" . $_sDescription . "</span>"; } } return $aField; } public function validation_TaskScheduler_AdminPage_EditModule_edit_occurrence( $aInput, $aOldInput ) { $_sRedirectURL = add_query_arg( array( 'transient_key' => $aInput['transient_key'], )); $_sRedirectURL = add_query_arg( array( 'transient_key' => $aInput['transient_key'], ), apply_filters( 'task_scheduler_admin_filter_wizard_occurrence_redirect_url_' . $aInput['occurrence'], $_sRedirectURL, $aInput ) ); $_sPreviousURLKey = remove_query_arg( array( 'transient_key', 'settings-notice', 'settings-updated' ), $_sRedirectURL ); $aInput['previous_urls'] = $this->_getWizardOptions( 'previous_urls' ); $aInput['previous_urls'] = is_array( $aInput['previous_urls'] ) ? $aInput['previous_urls'] : array(); $aInput['previous_urls'][ $_sPreviousURLKey ] = add_query_arg( array( 'transient_key' => $aInput['transient_key'], ) ); $aInput['occurrence_label'] = apply_filters( "task_scheduler_filter_label_occurrence_" . $aInput['occurrence'], $aInput['occurrence'] ); $aInput['_update_next_schedule'] = true; $this->_saveWizardOptions( $aInput['transient_key'], $aInput ); exit( wp_safe_redirect( $_sRedirectURL ) ); } }abstract class TaskScheduler_AdminPage_EditModule_Setup extends TaskScheduler_AdminPage_EditModule_Tab_Occurrence { public function setUp() { $this->setRootMenuPageBySlug( TaskScheduler_Registry::AdminPage_Root ); $this->addSubMenuItems( array( 'title' => __( 'Edit Module Options', 'task-scheduler' ), 'page_slug' => TaskScheduler_Registry::AdminPage_EditModule, 'show_in_menu' => false, ) ); $this->addInPageTabs( TaskScheduler_Registry::AdminPage_EditModule, array( 'tab_slug' => 'wizard', 'title' => __( 'Edit Module Options', 'task-scheduler' ), 'order' => 1, 'show_in_page_tab' => false, ) ); $this->_sTransientKey = isset( $_GET['transient_key'] ) && $_GET['transient_key'] ? $_GET['transient_key'] : TaskScheduler_Registry::TransientPrefix . uniqid(); $this->_defineStyles(); add_action( "load_" . TaskScheduler_Registry::AdminPage_EditModule, array( $this, '_replyToDefineFormElements' ) ); parent::setUp(); } public function _replyToDefineFormElements( $oAdminPage ) { $this->_registerCustomFieldTypes(); $this->_defineForm(); } }final class TaskScheduler_AdminPage_EditModule extends TaskScheduler_AdminPage_EditModule_Setup { public function options_TaskScheduler_AdminPage_EditModule( $aOptions ) { $_aWizardOptions = $this->_getWizardOptions(); if ( empty( $_aWizardOptions ) && isset( $_GET['transient_key'] ) ) { $_aWizardOptions = $this->_setWizardOptions( $_GET['transient_key'] ); } $_aWizardOptions = apply_filters( 'task_scheduler_admin_filter_wizard_options', $_aWizardOptions ); return array( 'edit_action' => $_aWizardOptions, 'edit_occurrence' => $_aWizardOptions, '_wizard_options' => $_aWizardOptions, ); } private function _setWizardOptions( $sTransientKey ) { if ( ! isset( $_GET['post'] ) ) { return array(); } $_aPostMeta = TaskScheduler_WPUtility::getPostMetas( $_GET['post'] ); set_transient( $sTransientKey, $_aPostMeta, 30*60 ); return $_aPostMeta; } }if ( ! class_exists( 'WP_List_Table' ) ) require_once( ABSPATH . 'wp-admin/includes/class-wp-list-table.php' ); class TaskScheduler_ListTable_Action extends WP_List_Table { public function get_bulk_actions() { $_sStatusQuery = isset( $_GET['status'] ) ? $_GET['status'] : ''; switch( $_sStatusQuery ) { default: case 'enabled': return array( 'disable' => __( 'Disable', 'task-scheduler' ), 'reset_status' => __( 'Reset Status', 'task-scheduler' ), 'reset_counts' => __( 'Reset Counts', 'task-scheduler' ), ); case 'disabled': return array( 'enable' => __( 'Enable', 'task-scheduler' ), 'delete' => __( 'Delete', 'task-scheduler' ), ); case 'thread': return array( 'delete' => __( 'Delete', 'task-scheduler' ), ); } } public function process_bulk_action() { if ( ! isset( $_REQUEST['task_scheduler_task'], $_REQUEST['task_scheduler_nonce'] ) ) { return; } if ( false === $this->getNonce( $_REQUEST['task_scheduler_nonce'] ) ) { $this->setAdminNotice( __( 'The action has been already done or is invalid.', 'task-scheduler' ) ); return; } $_iApplied = 0; $_sAdminNotice = ''; switch( strtolower( $this->current_action() ) ) { case 'enable': foreach( ( array ) $_REQUEST['task_scheduler_task'] as $_sTaskPostID ) { $_oTask = TaskScheduler_Routine::getInstance( $_sTaskPostID ); $_oTask->enable(); $this->setAdminNotice( __( 'The task has/ been enabled.', 'task-scheduler' ), 'updated' ); } break; case 'disable': foreach( ( array ) $_REQUEST['task_scheduler_task'] as $_sTaskPostID ) { $_oTask = TaskScheduler_Routine::getInstance( $_sTaskPostID ); $_oTask->disable(); $this->setAdminNotice( __( 'The task has/ been disabled.', 'task-scheduler' ), 'updated' ); } break; case 'delete': foreach( ( array ) $_REQUEST['task_scheduler_task'] as $_sTaskPostID ) { $_sKey = array_search( $_sTaskPostID, $this->aData ); if ( false !== $_sKey ) { unset( $this->aData[ $_sKey ] ); } $_oTask = TaskScheduler_Routine::getInstance( $_sTaskPostID ); if ( is_object( $_oTask ) ) { $_oTask->delete(); } $this->setAdminNotice( __( 'The task has/ been deleted.', 'task-scheduler' ) ); } break; case 'run': foreach( ( array ) $_REQUEST['task_scheduler_task'] as $_sTaskPostID ) { $_oTask = TaskScheduler_Routine::getInstance( $_sTaskPostID ); $_oTask->start( microtime( true ) + $_iApplied ); $this->setAdminNotice( __( 'The task has/ been called.', 'task-scheduler' ), 'updated' ); $_iApplied++; } break; case 'reset_status': foreach( ( array ) $_REQUEST['task_scheduler_task'] as $_sTaskPostID ) { $_oTask = TaskScheduler_Routine::getInstance( $_sTaskPostID ); $_oTask->resetStatus(); $_iApplied++; $this->setAdminNotice( __( 'Reset the status.', 'task-scheduler' ), 'updated' ); } break; case 'reset_counts': foreach( ( array ) $_REQUEST['task_scheduler_task'] as $_sTaskPostID ) { $_oTask = TaskScheduler_Routine::getInstance( $_sTaskPostID ); $_oTask->resetCounts(); $_iApplied++; $this->setAdminNotice( __( 'Reset the counts.', 'task-scheduler' ), 'updated' ); } break; default: break; } $this->deleteNonce( $_REQUEST['task_scheduler_nonce'] ); } }abstract class TaskScheduler_ListTable_Column extends TaskScheduler_ListTable_Action { public function get_columns() { return array( 'cb' => '<input type="checkbox" />', 'name' => __( 'Task Name', 'task-scheduler' ), 'details' => __( 'Details', 'task-scheduler' ), 'status' => __( 'Status', 'task-scheduler' ), 'last_run' => __( 'Last Run', 'task-scheduler' ), 'next_run' => __( 'Next Run', 'task-scheduler' ), ); } public function get_sortable_columns() { return array( 'last_run' => array( '_last_run_time', false ), 'next_run' => array( '_next_run_time', false ), ); } public function column_default( $aItem, $sColumnName ) { switch( $sColumnName ){ default: } } public function column_cb( $oRoutine ){ return sprintf( '<input type="checkbox" name="%1$s[]" value="%2$s" />', $this->_args['singular'], $oRoutine->ID ); } public function column_name( $oRoutine ) { $_aActions = array( 'edit' => sprintf( '<a href="%s">' . __( 'Edit', 'task-scheduler' ) . '</a>', get_edit_post_link( $oRoutine->ID, true ) ), 'enable' => sprintf( '<a href="%s">' . __( 'Enable', 'task-scheduler' ) . '</a>', $this->getQueryURL( array( 'action' => 'enable', 'task_scheduler_task' => $oRoutine->ID, 'task_scheduler_nonce' => $this->sNonce ) ) ), 'disable' => sprintf( '<a href="%s">' . __( 'Disable', 'task-scheduler' ) . '</a>', $this->getQueryURL( array( 'action' => 'disable', 'task_scheduler_task' => $oRoutine->ID, 'task_scheduler_nonce' => $this->sNonce ) ) ), 'delete' => sprintf( '<a href="%s">' . __( 'Delete', 'task-scheduler' ) . '</a>', $this->getQueryURL( array( 'action' => 'delete', 'task_scheduler_task' => $oRoutine->ID, 'task_scheduler_nonce' => $this->sNonce ) ) ), 'view' => sprintf( '<a href="%s" rel="permalink" title="' . esc_attr( sprintf( __( 'View &#8220;%s&#8221;' ), $oRoutine->post_title ) ) . '">' . __( 'View', 'task-scheduler' ) . '</a>', get_permalink( $oRoutine->ID ) ), 'run' => sprintf( '<a href="%s">' . __( 'Run Now', 'task-scheduler' ) . '</a>', add_query_arg( array( 'action' => 'run', 'task_scheduler_task' => $oRoutine->ID, 'task_scheduler_nonce' => $this->sNonce ) ) ), ); if ( isset( $_GET['status'] ) && 'disabled' == $_GET['status'] ) { unset( $_aActions['disable'], $_aActions['run'] ); } if ( ! isset( $_GET['status'] ) || 'enabled' == $_GET['status'] ) { unset( $_aActions['enable'], $_aActions['delete'] ); } if ( isset( $_GET['status'] ) && in_array( $_GET['status'], array( 'system', 'thread' ) ) ) { unset( $_aActions['edit'], $_aActions['view'] ); } if ( $oRoutine->isEnabled() ) { unset( $_aActions['enable'] ); } else { unset( $_aActions['disable'] ); } $_aIDBox = array( "<p class='routine-id-container'><span class='id-label'>" . __( 'ID', 'task-scheduler' ) . ":</span><span class='routine-id'>{$oRoutine->ID}</span></p>", $oRoutine->isThread() ? "<p class='routine-id-container'><span class='id-label'>" . __( 'Owner', 'task-scheduler' ) . ":</span><span class='routine-id'>{$oRoutine->owner_routine_id}</span></p>" : '' ); return "<div class='task-listing-table id-label-container'>" . implode( PHP_EOL, $_aIDBox ). "</div>" . "<p class='post-title page-title column-title'><strong>" . $oRoutine->post_title . "</strong></p>" . $this->row_actions( $_aActions ); } public function column_details( $oRoutine ) { $_sOccurrenceLabel = apply_filters( "task_scheduler_filter_label_occurrence_{$oRoutine->occurrence}", $oRoutine->occurrence ); $_sActionLabel = apply_filters( "task_scheduler_filter_label_action_{$oRoutine->routine_action}", $oRoutine->routine_action ); return "<p class='description'>" . $oRoutine->post_excerpt . "</p>" . "<p><span class='description-label'>" . __( 'Occurrence', 'task-scheduler' ) . ":</span> " . $_sOccurrenceLabel . "</p>" . "<p><span class='description-label'>" . __( 'Action', 'task-scheduler' ) . ":</span> " . $_sActionLabel . "</p>" ; } public function column_status( $oRoutine ) { $_sStatusLabel = $this->_getStatusLabel( $oRoutine->_routine_status ); $_iThreads = $oRoutine->getThreadCount(); $_sHasThreads = $_iThreads ? sprintf( __( '%1$s threads', 'task-scheduler' ), $_iThreads ) : __( 'No thread', 'task-scheduler' ); $_sElapsedTime = in_array( $oRoutine->_routine_status, array( 'processing', 'awaiting' ) ) ? $this->_getReadableElapsedTime( $oRoutine ) : ''; return "<p title='" . esc_attr( __( 'Status', 'task-scheduler' ) ) . "'>{$_sStatusLabel}</p>" . "<p title='" . esc_attr( __( 'Threads', 'task-scheduler' ) ) . "'>{$_sHasThreads}</p>" . ( $_sElapsedTime ? "<p title='" . esc_attr( __( 'Elapsed Time', 'task-scheduler' ) ) . "'> " . sprintf( __( 'Elapsed %1$s', 'task-scheduler' ), $_sElapsedTime ) . "</p>" : '' ); } private function _getReadableElapsedTime( $oRoutine ) { if ( ! $oRoutine->_spawned_time ) { return __( 'n/a', 'task-scheduler' ); } $_iElapsedSeconds = time() - ( int ) $oRoutine->_spawned_time; if ( $_iElapsedSeconds < 60 ) { return sprintf( __( '%1$s seconds', 'task-scheduler' ), $_iElapsedSeconds ); } return human_time_diff( ( int ) $oRoutine->_spawned_time, time() ); } private function _getStatusLabel( $sStatus ) { switch ( $sStatus ) { case '': case false: case null: return __( 'n/a', 'task-scheduler' ); case 'queued': return __( 'Queued', 'task-scheduler' ); case 'inactive': return __( 'Inactive', 'task-scheduler' ); case 'processing': return __( 'Processing', 'task-scheduler' ); case 'awaiting': return __( 'Awaiting', 'task-scheduler' ); default: return $_sStatus; break; } } public function column_last_run( $oRoutine ) { $_sExitCountDescription = __( 'Indicates how many times a valid exit code has been returned.', 'task-scheduler' ); $_sExitCodeDescription = __( 'Indicates the last exit code returned from the action.', 'task-scheduler' ); $_aOutput = array(); $_aOutput[] = "<p>" . $oRoutine->getReadableTime( $oRoutine->_last_run_time, 'Y/m/d G:i:s', true ) . "</p>"; if ( $oRoutine->isTask() ) { $_aOutput[] = "<p title='" . esc_attr( $_sExitCountDescription ) . "'>" . "<span class='description-label'>" . __( 'Exit Count', 'task-scheduler' ) . ":</span>" . ( $oRoutine->_count_exit ? $oRoutine->_count_exit : 0 ) . "</p>"; $_aOutput[] = "<p title='" . esc_attr( $_sExitCountDescription ) . "'>" . "<span class='description-label'>" . __( 'Hung Count', 'task-scheduler' ) . ":</span>" . ( $oRoutine->_count_hung ? $oRoutine->_count_hung : 0 ) . "</p>"; } return implode( PHP_EOL, $_aOutput ); } public function column_next_run( $oRoutine ) { $_sCallCountDescription = __( 'Indicates how many times the action has been called.', 'task-scheduler' ); $_sRunCountDescription = __( 'Indicates how many times the action has run.', 'task-scheduler' ) . ' &#10;' . __( 'This does not necessarily mean the action did the expected job.', 'task-scheduler' ); return "<p>" . $oRoutine->getReadableTime( $oRoutine->_next_run_time, 'Y/m/d G:i:s', true ) . "</p>" . "<p title='" . esc_attr( $_sCallCountDescription ) . "'>" . "<span class='description-label'>" . __( 'Call Count', 'task-scheduler' ) . ":</span>" . ( $oRoutine->_count_call ? $oRoutine->_count_call : 0 ) . "</p>" . "<p title='" . esc_attr( $_sRunCountDescription ) . "'>" . "<span class='description-label'>" . __( 'Run Count', 'task-scheduler' ) . ":</span>" . ( $oRoutine->_count_run ? $oRoutine->_count_run : 0 ) . "</p>"; } }abstract class TaskScheduler_ListTable_Views extends TaskScheduler_ListTable_Column { public function get_views() { $_aBaseKeys = array( 'enabled' => __( 'Enabled', 'task-scheduler' ) . " <span class='count'>(" . $this->_iEnabledTasks . ")</span>", 'disabled' => __( 'Disabled', 'task-scheduler' ) . " <span class='count'>(" . $this->_iDisabledTasks . ")</span>", 'system' => __( 'System', 'task-scheduler' ) . " <span class='count'>(" . $this->_iSystemTasks . ")</span>", 'thread' => __( 'Thread', 'task-scheduler' ) . " <span class='count'>(" . $this->_iThreadTasks . ")</span>", ); if ( ! $this->_iSystemTasks ) { unset( $_aBaseKeys[ 'system' ] ); } if ( ! $this->_iThreadTasks ) { unset( $_aBaseKeys[ 'thread' ] ); } $_aViews = array(); foreach ( $_aBaseKeys as $_sKey => $_sLabel ) { $_sSelfURL_StatusQuery = $this->getQueryURL( array( 'status' => $_sKey ) ); $_sCurrent = ( ! isset( $_GET['status'] ) && 'enabled' == $_sKey ) || ( isset( $_GET['status'] ) && $_sKey == $_GET['status'] ) ? 'current' : ''; $_aViews[ $_sKey ] = "<a href='{$_sSelfURL_StatusQuery}' class='{$_sCurrent}'>" . $_sLabel . "</a>"; } return $_aViews; } }class TaskScheduler_ListTable extends TaskScheduler_ListTable_Views { public $aData = array(); public $aArgs = array(); public $sNonce; protected $_aAdminNotices; protected $_aDisallowedQueryKeys = array( 'task_scheduler_nonce', 'action', 'task_scheduler_task', 'orderby', 'order', ); public function __construct( array $aData=array() ){ $this->aData = $aData; $this->aArgs = array( 'singular' => 'task_scheduler_task', 'plural' => 'task_scheduler_tasks', 'ajax' => false, 'screen' => null, ); if ( ! headers_sent() ) { add_action( 'admin_notices', array( $this, '_replyToDelayConstructor' ) ); } else { parent::__construct( $this->aArgs ); } } public function _replyToDelayConstructor() { parent::__construct( $this->aArgs ); } public function setNonce() { $this->sNonce = uniqid(); set_transient( TaskScheduler_Registry::TransientPrefix . $this->sNonce, $this->sNonce, 60*10 ); return $this->sNonce; } public function getNonce( $sNonce ) { return get_transient( TaskScheduler_Registry::TransientPrefix . $sNonce ); } public function deleteNonce( $sNonnce ) { delete_transient( TaskScheduler_Registry::TransientPrefix . $sNonnce ); } public function getQueryURL( array $aKeyValues, $sURL=null ) { $sURL = $sURL ? $sURL : $_SERVER['REQUEST_URI']; $_sModifiedURL = add_query_arg( $aKeyValues, $sURL ); $_aDisallowedQueryKeys = array_diff( $this->_aDisallowedQueryKeys, array_keys( $aKeyValues ) ); return remove_query_arg( $_aDisallowedQueryKeys, $_sModifiedURL ); } public function setAdminNotice( $sMessage, $sType='error' ) { $this->_aAdminNotices[ md5( trim( $sMessage ) . $sType ) ] = array( 'message' => $sMessage, 'type' => $sType ); static $_bLoaded; if ( $_bLoaded ) { return; } $_bLoaded = true; add_action( 'admin_notices', array( $this, '_replyToPrintAdminNotice' ) ); } public function _replyToPrintAdminNotice() { foreach( $this->_aAdminNotices as $_aAdminNotice ) { echo '<div class="' . $_aAdminNotice['type'] . '">' . '<p>' . $_aAdminNotice['message'] . '</p>' . '</div>'; } } function prepare_items() { $iItemsPerPage = 20; $this->_column_headers = array( $this->get_columns(), array(), $this->get_sortable_columns() ); $_aData = $this->aData; $iCurrentPageNumber = $this->get_pagenum(); $iTotalItems = count( $_aData ); $this->set_pagination_args( array( 'total_items' => $iTotalItems, 'per_page' => $iItemsPerPage, 'total_pages' => ceil( $iTotalItems / $iItemsPerPage ) ) ); $_aData = array_slice( $_aData, ( ( $iCurrentPageNumber - 1 ) * $iItemsPerPage ), $iItemsPerPage ); $this->items = array(); foreach( $_aData as $_iIndex => $_iPostID ) { $this->items[ $_iIndex ] = TaskScheduler_Routine::getInstance( $_iPostID ); } usort( $this->items, array( $this, 'usort_reorder' ) ); } public function usort_reorder( $a, $b ) { $_sOrderBy = ! empty( $_REQUEST['orderby'] ) ? $_REQUEST['orderby'] : 'post_date'; $_sOrder = ! empty( $_REQUEST['order'] ) ? $_REQUEST['order'] : 'desc'; $_iResult = 1; if ( is_array( $a ) && is_array( $b ) ) { $_iResult = strcmp( $a[ $_sOrderBy ], $b[ $_sOrderBy ] ); } else if ( is_object( $a ) && is_object( $b ) ){ $_iResult = strcmp( $a->{$_sOrderBy} , $b->{$_sOrderBy} ); } return ( 'desc' === $_sOrder ) ? -$_iResult : $_iResult; } }final class TaskScheduler_AutoLoad { public $_aClasses = array(); static protected $_aStructure_RecursiveOptions = array( 'is_recursive' => true, 'exclude_dir_paths' => array(), 'exclude_dir_names' => array( 'asset', 'assets', 'css', 'js', 'image', 'images', 'license', 'document', 'documents' ), 'allowed_extensions' => array( 'php', ), ); function __construct( $sClassDirPath, array $aSearchOptions=array(), array $aClasses=array() ) { $this->_aClasses = $aClasses + $this->_constructClassArray( $sClassDirPath, $aSearchOptions + self::$_aStructure_RecursiveOptions ); $this->_registerClasses(); } protected function _constructClassArray( $sClassDirPath, array $aSearchOptions ) { $_aFilePaths = $this->getFilePaths( $sClassDirPath, $aSearchOptions ); $_aClasses = array(); foreach( $_aFilePaths as $_sFilePath ) { $_aClasses[ pathinfo( $_sFilePath, PATHINFO_FILENAME ) ] = $_sFilePath; } return $_aClasses; } protected function getFilePaths( $sClassDirPath, array $aSearchOptions ) { $sClassDirPath = rtrim( $sClassDirPath, '\\/' ) . DIRECTORY_SEPARATOR; $_aAllowedExtensions = $aSearchOptions['allowed_extensions']; $_aExcludeDirPaths = ( array ) $aSearchOptions['exclude_dir_paths']; $_aExcludeDirNames = ( array ) $aSearchOptions['exclude_dir_names']; $_bIsRecursive = $aSearchOptions[ 'is_recursive' ]; if ( defined( 'GLOB_BRACE' ) ) { $_aFilePaths = $_bIsRecursive ? $this->doRecursiveGlob( $sClassDirPath . '*.' . $this->_getGlobPatternExtensionPart( $_aAllowedExtensions ), GLOB_BRACE, $_aExcludeDirPaths, $_aExcludeDirNames ) : ( array ) glob( $sClassDirPath . '*.' . $this->_getGlobPatternExtensionPart( $_aAllowedExtensions ), GLOB_BRACE ); return array_filter( $_aFilePaths ); } $_aFilePaths = array(); foreach( $_aAllowedExtensions as $__sAllowedExtension ) { $__aFilePaths = $_bIsRecursive ? $this->doRecursiveGlob( $sClassDirPath . '*.' . $__sAllowedExtension, 0, $_aExcludeDirPaths, $_aExcludeDirNames ) : ( array ) glob( $sClassDirPath . '*.' . $__sAllowedExtension ); $_aFilePaths = array_merge( $__aFilePaths, $_aFilePaths ); } return array_unique( array_filter( $_aFilePaths ) ); } protected function _getGlobPatternExtensionPart( array $aExtensions=array( 'php', 'inc' ) ) { return empty( $aExtensions ) ? '*' : '{' . implode( ',', $aExtensions ) . '}'; } protected function doRecursiveGlob( $sPathPatten, $nFlags=0, array $aExcludeDirs=array(), array $aExcludeDirNames=array() ) { $_aFiles = glob( $sPathPatten, $nFlags ); $_aFiles = is_array( $_aFiles ) ? $_aFiles : array(); $_aDirs = glob( dirname( $sPathPatten ) . DIRECTORY_SEPARATOR . '*', GLOB_ONLYDIR|GLOB_NOSORT ); $_aDirs = is_array( $_aDirs ) ? $_aDirs : array(); foreach ( $_aDirs as $_sDirPath ) { if ( in_array( $_sDirPath, $aExcludeDirs ) ) { continue; } if ( in_array( pathinfo( $_sDirPath, PATHINFO_DIRNAME ), $aExcludeDirNames ) ) { continue; } $_aFiles = array_merge( $_aFiles, $this->doRecursiveGlob( $_sDirPath . DIRECTORY_SEPARATOR . basename( $sPathPatten ), $nFlags, $aExcludeDirs ) ); } return $_aFiles; } protected function _registerClasses() { spl_autoload_register( array( $this, '_replyToAutoLoad' ) ); } public function _replyToAutoLoad( $sCalledUnknownClassName ) { if ( ! array_key_exists( $sCalledUnknownClassName, $this->_aClasses ) ) { return; } if ( ! file_exists( $this->_aClasses[ $sCalledUnknownClassName ] ) ) { return; } include( $this->_aClasses[ $sCalledUnknownClassName ] ); } }final class TaskScheduler_Bootstrap { function __construct( $sPluginFilePath ) { TaskScheduler_Debug::log( 'booting' ); $this->_sFilePath = $sPluginFilePath; $this->_bIsAdmin = is_admin(); $this->_loadClasses( $this->_sFilePath ); register_activation_hook( $this->_sFilePath, array( $this, '_replyToDoWhenPluginActivates' ) ); register_deactivation_hook( $this->_sFilePath, array( $this, '_replyToDoWhenPluginDeactivates' ) ); $this->_localize(); add_action( 'admin_init', array( $this, '_replyToCheckRequirements' ) ); add_action( 'plugins_loaded', array( $this, '_replyToLoadPluginComponents' ) ); } private function _setGlobalVariables() {} private function _loadClasses( $sFilePath ) { $_sPluginDir = dirname( $sFilePath ); if ( class_exists( 'TaskScheduler_AutoLoad' ) ) { return; } $this->_includeLibraries(); include( $_sPluginDir . '/include/class/boot/TaskScheduler_AutoLoad.php' ); new TaskScheduler_AutoLoad( $_sPluginDir . '/include/class' ); } protected function _includeLibraries() { include( TaskScheduler_Registry::$sDirPath . '/include/library/admin-page-framework/task-scheduler-admin-page-framework.min.php' ); include( TaskScheduler_Registry::$sDirPath . '/include/library/admin-page-framework/autocomplete-custom-field-type/TaskScheduler_AutoCompleteCustomFieldType.php' ); include( TaskScheduler_Registry::$sDirPath . '/include/library/admin-page-framework/date-time-custom-field-types/TaskScheduler_DateRangeCustomFieldType.php' ); include( TaskScheduler_Registry::$sDirPath . '/include/library/admin-page-framework/date-time-custom-field-types/TaskScheduler_DateTimeCustomFieldType.php' ); include( TaskScheduler_Registry::$sDirPath . '/include/library/admin-page-framework/date-time-custom-field-types/TaskScheduler_DateTimeRangeCustomFieldType.php' ); include( TaskScheduler_Registry::$sDirPath . '/include/library/admin-page-framework/date-time-custom-field-types/TaskScheduler_DateCustomFieldType.php' ); include( TaskScheduler_Registry::$sDirPath . '/include/library/admin-page-framework/date-time-custom-field-types/TaskScheduler_TimeCustomFieldType.php' ); include( TaskScheduler_Registry::$sDirPath . '/include/library/admin-page-framework/date-time-custom-field-types/TaskScheduler_TimeRangeCustomFieldType.php' ); include( TaskScheduler_Registry::$sDirPath . '/include/library/admin-page-framework/revealer-custom-field-type/TaskScheduler_RevealerCustomFieldType.php' ); } public function _replyToCheckRequirements() { new TaskScheduler_Requirements( $this->_sFilePath, array( 'php' => array( 'version' => TaskScheduler_Registry::RequiredPHPVersion, 'error' => __( 'The plugin requires the PHP version %1$s or higher.', 'task-scheduler' ), ), 'wordpress' => array( 'version' => TaskScheduler_Registry::RequiredWordPressVersion, 'error' => __( 'The plugin requires the WordPress version %1$s or higher.', 'task-scheduler' ), ), 'functions' => array( 'curl_version' => sprintf( __( 'The plugin requires the %1$s to be installed.', 'task-scheduler' ), 'the cURL library' ), ), 'constants' => array(), ) ); } public function _replyToDoWhenPluginActivates() { add_action( 'shutdown', array( $this, '_replyToStartServerHeartbeat' ) ); if ( ! wp_next_scheduled( 'task_scheduler_action_check_heartbeat_hourly' ) ) { wp_schedule_single_event( time(), 'task_scheduler_action_check_heartbeat_hourly' ); wp_schedule_event( time(), 'hourly', 'task_scheduler_action_check_heartbeat_hourly' ); } } public function _replyToStartServerHeartbeat() { $this->_replyToLoadPluginComponents(); TaskScheduler_Event_ServerHeartbeat_Resumer::resume(); } public function _replyToDoWhenPluginDeactivates() { TaskScheduler_WPUtility::clearTransients( TaskScheduler_Registry::TransientPrefix ); TaskScheduler_WPUtility::unscheduleWPCronEventsByName( 'task_scheduler_action_check_heartbeat_hourly' ); if ( TaskScheduler_Option::get( array( 'reset', 'reset_upon_deactivation' ) ) ) { delete_option( TaskScheduler_Registry::OptionKey ); } } private function _localize() { load_plugin_textdomain( TaskScheduler_Registry::TextDomain, false, dirname( plugin_basename( $this->_sFilePath ) ) . '/language/' ); if ( $this->_bIsAdmin ) { load_plugin_textdomain( 'admin-page-framework', false, dirname( plugin_basename( $this->_sFilePath ) ) . '/language/' ); } } public function _replyToLoadPluginComponents() { TaskScheduler_Debug::log( 'plugins loaded' ); new TaskScheduler_Event; TaskScheduler_Debug::log( 'loaded events' ); new TaskScheduler_PostType_Task( TaskScheduler_Registry::PostType_Task, null, $this->_sFilePath ); new TaskScheduler_PostType_Thread( TaskScheduler_Registry::PostType_Thread, null, $this->_sFilePath ); new TaskScheduler_PostType_Log( TaskScheduler_Registry::PostType_Log, null, $this->_sFilePath ); TaskScheduler_Debug::log( 'loaded post types' ); if ( $this->_bIsAdmin ) { $this->oAdminPage = new TaskScheduler_AdminPage( '', $this->_sFilePath ); new TaskScheduler_AdminPage_Wizard( '', $this->_sFilePath ); new TaskScheduler_AdminPage_EditModule( '', $this->_sFilePath ); new TaskScheduler_AdminPage_Setting( TaskScheduler_Registry::OptionKey, $this->_sFilePath ); $this->_registerMetaBoxes(); TaskScheduler_Debug::log( 'loaded admin classes' ); } do_action( 'task_scheduler_action_after_loading_plugin' ); TaskScheduler_Debug::log( 'done bootstrap' ); } protected function _registerMetaBoxes() { if ( ! isset( $GLOBALS['pagenow'] ) || 'post.php' !== $GLOBALS['pagenow'] ) { return; } new TaskScheduler_MetaBox_Main( 'task_scheduler_meta_box_main', __( 'Main', 'task-scheduler' ), array( TaskScheduler_Registry::PostType_Task, TaskScheduler_Registry::PostType_Thread ), 'normal', 'high' ); new TaskScheduler_MetaBox_Occurrence( 'task_scheduler_meta_box_occurrence', __( 'Occurrence', 'task-scheduler' ), array( TaskScheduler_Registry::PostType_Task, TaskScheduler_Registry::PostType_Thread ), 'normal', 'default' ); new TaskScheduler_MetaBox_Action( 'task_scheduler_meta_box_action', __( 'Action', 'task-scheduler' ), array( TaskScheduler_Registry::PostType_Task, TaskScheduler_Registry::PostType_Thread ), 'normal', 'low' ); new TaskScheduler_MetaBox_Advanced( 'task_scheduler_meta_box_advanced', __( 'Advanced', 'task-scheduler' ), array( TaskScheduler_Registry::PostType_Task, TaskScheduler_Registry::PostType_Thread ), 'advanced', 'default' ); new TaskScheduler_MetaBox_Submit( 'task_scheduler_meta_box_submit', __( 'Update', 'task-scheduler' ), array( TaskScheduler_Registry::PostType_Task, TaskScheduler_Registry::PostType_Thread ), 'side', 'high' ); } }final class TaskScheduler_Requirements { private $_aWarnings = array(); private $_iExitCode = 1; private $_aParams = array(); private $_aDefaultParams = array( 'php' => array( 'version' => '5.2.4', 'error' => 'The plugin requires the PHP version %1$s or higher.', ), 'wordpress' => array( 'version' => '3.3', 'error' => 'The plugin requires the WordPress version %1$s or higher.', ), 'functions' => array( ), 'classes' => array( ), 'constants' => array( ), 'files' => array( ), ); private $_sPluginFilePath; private $_sTextDomain = ''; function __construct( $sPluginFilePath, $aParams=array(), $iExitCode=1, $sHook='', $_sTextDomain='' ) { $this->_aParams = $aParams + $this->_aDefaultParams; $this->_aParams['php'] = $this->_aParams['php'] + $this->_aDefaultParams['php']; $this->_aParams['wordpress'] = $this->_aParams['wordpress'] + $this->_aDefaultParams['wordpress']; $this->_sPluginFilePath = $sPluginFilePath; $this->_iExitCode = $iExitCode; if ( ! empty( $sHook ) ) add_action( $sHook, array( $this, 'check' ) ); else if ( $sHook === '' ) $this->check(); else if ( is_null( $sHook ) ) return $this; } public function isSufficient() { return empty( $this->_aWarnings ); } public function setWarning( $sWarningMessage ) { add_action( 'admin_notices', array( $this, '_replyToPrintAdminNotice' ) ); $this->_aWarnings[] = $sWarningMessage; } public function check() { if ( ! $this->_isSufficientPHPVersion( $this->_aParams['php']['version'] ) ) { $this->_aWarnings[] = sprintf( $this->_aParams['php']['error'], $this->_aParams['php']['version'] ); } if ( ! $this->_isSufficientWordPressVersion( $this->_aParams['wordpress']['version'] ) ) { $this->_aWarnings[] = sprintf( $this->_aParams['wordpress']['error'], $this->_aParams['wordpress']['version'] ); } $_aNonFoundFuncs = $this->_checkFunctions( $this->_aParams['functions'] ); if ( ! empty( $_aNonFoundFuncs ) ) { foreach ( $_aNonFoundFuncs as $i => $sError ) $this->_aWarnings[] = $sError; } $_aNonFoundClasses = $this->_checkClasses( $this->_aParams['classes'] ); if ( ! empty( $_aNonFoundClasses ) ) { foreach ( $_aNonFoundClasses as $i => $sError ) $this->_aWarnings[] = $sError; } $_aNonFoundConstants = $this->_checkConstants( $this->_aParams['constants'] ); if ( ! empty( $_aNonFoundConstants ) ) { foreach ( $_aNonFoundConstants as $i => $sError ) $this->_aWarnings[] = $sError; } $_aNonFoundFiles = $this->_checkFiles( $this->_aParams['files'] ); if ( ! empty( $_aNonFoundFiles ) ) { foreach ( $_aNonFoundFiles as $i => $sError ) $this->_aWarnings[] = $sError; } if ( ! empty( $this->_aWarnings ) ) { add_action( 'admin_notices', array( $this, '_replyToPrintAdminNotice' ) ); if ( $this->_iExitCode === 1 || $this->_iExitCode === true ) { $this->_aWarnings[] = '<strong>' . __( 'Deactivating the plugin.', $this->_sTextDomain ) . '</strong>'; $this->includeOnce( ABSPATH . '/wp-admin/includes/plugin.php' ); deactivate_plugins( $this->_sPluginFilePath ); } else if ( $this->_iExitCode === 2 ) { $this->_aWarnings[] = '<strong>' . __( 'Exiting the script.', $this->_sTextDomain ) . '</strong>'; die( $this->_getWarnings( $this->_aWarnings, $this->_sPluginFilePath, $this->_iExitCode ) ); } } } private function includeOnce( $sPath ) { if ( ! file_exists( $sPath ) ) return false; include_once( $sPath ); return true; } public function _replyToPrintAdminNotice() { echo $this->_getWarnings( $this->_aWarnings, $this->_sPluginFilePath, $this->_iExitCode ); } private function _getWarnings( $aWarnings, $sScriptPath, $iExitCode ) { $aWarnings = array_unique( $aWarnings ); $sPluginName = $this->_getScriptName( $sScriptPath ); return "<div class='error'>" . "<p>" . ( $sPluginName ? "<strong>" . $sPluginName . "</strong>:&nbsp;" : '' ) . implode( '<br />', $aWarnings ) . "</p>" . "</div>"; } private function _getScriptName( $sFilePath ) { $aPluginData = get_plugin_data( $sFilePath ); return isset( $aPluginData['Name'] ) ? $aPluginData['Name'] : ''; } private function _isSufficientPHPVersion( $sPHPVersion ) { return version_compare( phpversion(), $sPHPVersion, ">=" ); } private function _isSufficientWordPressVersion( $sWordPressVersion ) { return version_compare( $GLOBALS['wp_version'], $sWordPressVersion, ">=" ); } private function _checkClasses( $aClasses ) { return $this->_getNonExistents( 'class_exists', $aClasses ); } private function _checkFunctions( $aFuncs ) { return $this->_getNonExistents( 'function_exists', $aFuncs ); } private function _checkConstants( $aConstants ) { return $this->_getNonExistents( 'defined', $aConstants ); } private function _checkFiles( $aFilePaths ) { return $this->_getNonExistents( 'file_exists', $aFilePaths ); } private function _getNonExistents( $sFuncName, $aSubjects ) { $aNonExistents = array(); foreach( $aSubjects as $sSubject => $sError ) { if ( ! call_user_func_array( $sFuncName, array( $sSubject ) ) ) { $aNonExistents[] = sprintf( $sError, $sSubject ); } } return $aNonExistents; } }final class TaskScheduler_Debug { static public function dump( $v, $sFilePath=null ) { if ( ! defined( 'WP_DEBUG' ) || ! WP_DEBUG ) return; echo self::get( $v, $sFilePath ); } static public function get( $v, $sFilePath=null ) { if ( ! defined( 'WP_DEBUG' ) || ! WP_DEBUG ) return; if ( $sFilePath ) { self::log( $v, $sFilePath ); } return "<div><pre class='dump-array'>" . htmlspecialchars( print_r( $v, true ) ) . "</pre><div>"; } static public function log( $v, $sFilePath=null ) { if ( ! defined( 'WP_DEBUG' ) || ! WP_DEBUG ) return; static $_iPageLoadID; static $_nGMTOffset; static $_fPreviousTimeStamp = 0; $_iPageLoadID = $_iPageLoadID ? $_iPageLoadID : uniqid(); $_oCallerInfo = debug_backtrace(); $_sCallerFunction = isset( $_oCallerInfo[ 1 ]['function'] ) ? $_oCallerInfo[ 1 ]['function'] : ''; $_sCallerClasss = isset( $_oCallerInfo[ 1 ]['class'] ) ? $_oCallerInfo[ 1 ]['class'] : ''; $sFilePath = ! $sFilePath ? WP_CONTENT_DIR . DIRECTORY_SEPARATOR . get_class() . '_' . $_sCallerClasss . '_' . date( "Ymd" ) . '.log' : ( true === $sFilePath ? WP_CONTENT_DIR . DIRECTORY_SEPARATOR . get_class() . '_' . date( "Ymd" ) . '.log' : $sFilePath ); $_nGMTOffset = isset( $_nGMTOffset ) ? $_nGMTOffset : get_option( 'gmt_offset' ); $_fCurrentTimeStamp = microtime( true ); $_nNow = $_fCurrentTimeStamp + ( $_nGMTOffset * 60 * 60 ); $_nMicroseconds = round( ( $_nNow - floor( $_nNow ) ) * 10000 ); $_nMicroseconds = str_pad( $_nMicroseconds, 4, '0' ); $_nElapsed = round( $_fCurrentTimeStamp - $_fPreviousTimeStamp, 3 ); $_aElapsedParts = explode( ".", ( string ) $_nElapsed ); $_sElapsedFloat = str_pad( isset( $_aElapsedParts[ 1 ] ) ? $_aElapsedParts[ 1 ] : 0, 3, '0' ); $_sElapsed = isset( $_aElapsedParts[ 0 ] ) ? $_aElapsedParts[ 0 ] : 0; $_sElapsed = strlen( $_sElapsed ) > 1 ? '+' . substr( $_sElapsed, -1, 2 ) : ' ' . $_sElapsed; $_sHeading = date( "Y/m/d H:i:s", $_nNow ) . '.' . $_nMicroseconds . ' ' . $_sElapsed . '.' . $_sElapsedFloat . ' ' . "{$_iPageLoadID} {$_sCallerClasss}::{$_sCallerFunction} " . current_filter() . ' ' . self::getCurrentURL(); file_put_contents( $sFilePath, $_sHeading . PHP_EOL . print_r( $v, true ) . PHP_EOL . PHP_EOL, FILE_APPEND ); $_fPreviousTimeStamp = $_fCurrentTimeStamp; } static public function getCurrentURL() { $sSSL = ( !empty( $_SERVER['HTTPS'] ) && $_SERVER['HTTPS'] == 'on' ) ? true:false; $sServerProtocol = strtolower( $_SERVER['SERVER_PROTOCOL'] ); $sProtocol = substr( $sServerProtocol, 0, strpos( $sServerProtocol, '/' ) ) . ( ( $sSSL ) ? 's' : '' ); $sPort = $_SERVER['SERVER_PORT']; $sPort = ( ( !$sSSL && $sPort=='80' ) || ( $sSSL && $sPort=='443' ) ) ? '' : ':' . $sPort; $sHost = isset( $_SERVER['HTTP_X_FORWARDED_HOST'] ) ? $_SERVER['HTTP_X_FORWARDED_HOST'] : isset( $_SERVER['HTTP_HOST'] ) ? $_SERVER['HTTP_HOST'] : $_SERVER['SERVER_NAME']; return $sProtocol . '://' . $sHost . $sPort . $_SERVER['REQUEST_URI']; } }abstract class TaskScheduler_Utility { static public function isJSON( $str ) { if ( ! is_string( $str ) ) { return false; } $_v = json_decode( $str ); return is_object( $_v ) || is_array( $_v ); } static public function implodeByKeyValues( array $aSubject ) { return http_build_query( $aSubject, '', ', ' ); } static public function swapElements( array &$aSubject, $isSourceKey, $isDestinationKey ) { $_vTemp = $aSubject[ $isDestinationKey ]; $aSubject[ $isDestinationKey ] = $aSubject[ $isSourceKey ]; $aSubject[ $isSourceKey ] = $_vTemp; return $aSubject; } static public function uniteArrays( $arrPrecedence, $arrDefault1 ) { $arrArgs = array_reverse( func_get_args() ); $arrArray = array(); foreach( $arrArgs as $arrArg ) $arrArray = self::uniteArraysRecursive( $arrArg, $arrArray ); return $arrArray; } static public function uniteArraysRecursive( $arrPrecedence, $arrDefault ) { if ( is_null( $arrPrecedence ) ) $arrPrecedence = array(); if ( ! is_array( $arrDefault ) || ! is_array( $arrPrecedence ) ) return $arrPrecedence; foreach( $arrDefault as $strKey => $v ) { if ( ! array_key_exists( $strKey, $arrPrecedence ) || is_null( $arrPrecedence[ $strKey ] ) ) $arrPrecedence[ $strKey ] = $v; else { if ( is_array( $arrPrecedence[ $strKey ] ) && is_array( $v ) ) $arrPrecedence[ $strKey ] = self::uniteArraysRecursive( $arrPrecedence[ $strKey ], $v ); } } return $arrPrecedence; } static public function canUseIniSet() { static $_bCanUse; if ( isset( $_bCanUse ) ) { return $_bCanUse; } $_bCanUse = ! function_exists( 'ini_set' ) ? false : ( false === @ini_set( get_class(), get_class() ) ); return $_bCanUse; } static public function getServerAllowedMaxExecutionTime( $iDefault=30 ) { if ( function_exists( 'ini_get' ) ) { $_iMaxExecutionTime = @ini_get( 'max_execution_time' ); return ! $_iMaxExecutionTime && 0 !== $_iMaxExecutionTime ? $iDefault : $_iMaxExecutionTime; } return $iDefault; } static public function sanitizeCharsForURLQueryKey( $sString ) { $sString = trim( $sString ); $_sSearch = array( chr( 32 ), chr( 46 ), chr( 91 ) ); for ( $i=128; $i <= 159; $i++ ) { array_push( $_sSearch, chr( $i ) ); } return str_replace( $_sSearch, '_', $sString ); } }abstract class TaskScheduler_WPUtility_Post extends TaskScheduler_Utility { static public function doesPostExist( $iID ) { return is_string( get_post_status( $iID ) ); } static public function getRegisteredPostTypeLabels( $aArgs=array() ) { $_aPostTypes = array(); $_aArgs = array( ); foreach( get_post_types( $aArgs, 'objects', 'and' ) as $_oPostType ) { if ( ! isset( $_oPostType->name, $_oPostType->label ) ) continue; $_aPostTypes[ $_oPostType->name ] = $_oPostType->label; } return $_aPostTypes; } static public function getRegisteredPostStatusLabels() { static $_aPostStatusLabels; if ( isset( $_aPostStatusLabels ) ) { return $_aPostStatusLabels; } $_aPostStatusLabels = array(); $_aRegisteredPostStatuses = get_post_stati( array(), '' ); foreach( $_aRegisteredPostStatuses as $_sSlug => $_oPostStatus ) { $_aPostStatusLabels[ $_sSlug ] = $_oPostStatus->label; } return $_aPostStatusLabels; } public static function getExcerpt( $iPostID ) { return get_post( $iPostID )->post_excerpt; } public static function getNumberOfChildren( $iPostID, $sPostType='any' ) { $_aArgs = array( 'numberposts' => -1, 'post_parent' => $iPostID, 'post_type' => $sPostType, ); return ( count( get_children( $_aArgs ) ) > 0 ); } public static function getParentPost( $iPostID ) { return get_post( $iPostID )->post_parent; } public static function getPostMetas( $iPostID ) { $_aPostData = array(); foreach( ( array ) get_post_custom_keys( $iPostID ) as $_sKey ) { $_aPostData[ $_sKey ] = get_post_meta( $iPostID, $_sKey, true ); } return $_aPostData; } public static function insertPost( array $aPostMeta, $sPostTypeSlug ) { if ( ! is_object( $GLOBALS['wpdb'] ) || ! is_object( $GLOBALS['wp_rewrite'] ) ) return; static $_iUserID; $_iUserID = isset( $_iUserID ) ? $_iUserID : get_current_user_id(); $_aDefaults = array( 'post_type' => $sPostTypeSlug, 'post_date' => date( 'Y-m-d H:i:s' ), 'comment_status' => 'closed', 'ping_status' => 'closed', 'post_status' => 'publish', ) + array( 'post_author' => $_iUserID, 'post_parent' => 0, 'menu_order' => 0, 'to_ping' => '', 'pinged' => '', 'post_password' => '', 'guid' => '', 'post_content_filtered' => '', 'post_excerpt' => '', 'import_id' => 0, 'post_content' => '', 'post_title' => '', 'tax_input' => null, ); $_aPostArguments = array(); foreach( $_aDefaults as $_sKey => $_sValue ) { $_aPostArguments[ $_sKey ] = isset( $aPostMeta[ $_sKey ] ) ? $aPostMeta[ $_sKey ] : $_sValue; } $_iPostID = wp_insert_post( $_aPostArguments ); foreach( $_aDefaults as $_sKey => $_sFieldKey ) { unset( $aPostMeta[ $_sKey ] ); } self::updatePostMeta( $_iPostID, $aPostMeta ); return $_iPostID; } static public function updatePostMeta( $iPostID, $aPostMeta ) { foreach( $aPostMeta as $_sFieldID => $_vValue ) { update_post_meta( $iPostID, $_sFieldID, $_vValue ); } } }class TaskScheduler_WPUtility extends TaskScheduler_WPUtility_Post { static public function getTransientWithoutCache( $sTransientKey ) { if ( wp_using_ext_object_cache() ) { return wp_cache_get( $sTransientKey, 'transient', true ); } global $wpdb; $_oRow = $wpdb->get_row( $wpdb->prepare( "SELECT option_value FROM $wpdb->options WHERE option_name = %s LIMIT 1", '_transient_' . $sTransientKey ) ); return is_object( $_oRow ) ? $_oRow->option_value: false; } static public function getTaxonomiyLabelBySlug( $sTaxonomySlug ) { $_oTaxonomy = get_taxonomy( $sTaxonomySlug ); return isset( $_oTaxonomy->labels->name ) ? $_oTaxonomy->labels->name : ''; } static public function getTaxonomiesByPostTypeSlug( $sPostTypeSlug ) { $_aLabels = array(); $_aTaxonomyObjects = get_object_taxonomies( $sPostTypeSlug, 'objects' ); foreach( $_aTaxonomyObjects as $_sTaxonomySlug => $_oTaxonomy ) { if ( ! isset( $_oTaxonomy->labels->name ) ) continue; $_aLabels[ $_sTaxonomySlug ] = $_oTaxonomy->labels->name; } return $_aLabels; } static public function getPostTypeLabel( $sPostTypeSlug ) { $_oPostType = get_post_type_object( $sPostTypeSlug ); return isset( $_oPostType->labels->singular_name ) ? $_oPostType->labels->singular_name : ''; } static public function clearTransients( $sPrefix ) { if ( ! isset( $GLOBALS['wpdb'], $GLOBALS['table_prefix'] ) ) return; $GLOBALS['wpdb']->query( "DELETE FROM `" . $GLOBALS['table_prefix'] . "options` WHERE `option_name` LIKE ( '_transient_%{$sPrefix}%' )" ); $GLOBALS['wpdb']->query( "DELETE FROM `" . $GLOBALS['table_prefix'] . "options` WHERE `option_name` LIKE ( '_transient_timeout_%{$sPrefix}%' )" ); } static public function getRedableMySQLDate( $sMySQLDate, $sDateTimeFormat=null, $bAdjustGMT=false ) { return self::getSiteReadableDate( mysql2date( 'U' , $sMySQLDate ), $sDateTimeFormat, $bAdjustGMT ); } static public function getSiteReadableDate( $iTimeStamp, $sDateTimeFormat=null, $bAdjustGMT=false ) { static $_iOffsetSeconds, $_sDateFormat, $_sTimeFormat; $_iOffsetSeconds = $_iOffsetSeconds ? $_iOffsetSeconds : get_option( 'gmt_offset' ) * HOUR_IN_SECONDS; $_sDateFormat = $_sDateFormat ? $_sDateFormat : get_option( 'date_format' ); $_sTimeFormat = $_sTimeFormat ? $_sTimeFormat : get_option( 'time_format' ); $sDateTimeFormat = $sDateTimeFormat ? $sDateTimeFormat : $_sDateFormat . ' ' . $_sTimeFormat; if ( ! $iTimeStamp ) { return 'n/a'; } $iTimeStamp = $bAdjustGMT ? $iTimeStamp + $_iOffsetSeconds : $iTimeStamp; return date_i18n( $sDateTimeFormat, $iTimeStamp ); } static public function unscheduleWPCronEventsByName( $asEventNames ) { $aEventNames = ( array ) $asEventNames; $_aCronEvents = _get_cron_array(); foreach ( $_aCronEvents as $__nTimeStamp => $__aEvent ) { foreach( $aEventNames as $sEventName ) { if ( isset( $_aCronEvents[ $__nTimeStamp ][ $sEventName ] ) ) { unset( $_aCronEvents[ $__nTimeStamp ] ); } } } _set_cron_array( $_aCronEvents ); } }class TaskScheduler_PluginUtility extends TaskScheduler_WPUtility { static public function getListFromAssociativeArray( array $aArray ) { $_aList = array(); foreach( $aArray as $_sKey => $_vValue ) { $_aList[] = "<li>" . "<span class='key_label'>" . $_sKey . "</span>" . "<span class='value_container'>" . ( is_array( $_vValue ) ? self::getListFromAssociativeArray( $_vValue ) : $_vValue ) . "</span>" . "</li>"; } return "<ul class='key-value-container'>" . implode( PHP_EOL, $_aList ) . "</ul>"; } public static function goToAddNewPage() { wp_safe_redirect( add_query_arg( array( 'page' => TaskScheduler_Registry::AdminPage_AddNew, ), admin_url( 'admin.php' ) ) ); } public static function goToEditTaskPage() { wp_safe_redirect( self::getEditTaskPageURL() ); } public static function getEditTaskPageURL() { return add_query_arg( array( 'post' => isset( $_GET['post'] ) ? $_GET['post'] : '', 'action' => 'edit', ), admin_url( "post.php" ) ); } public static function goToModuleEditPage() { wp_safe_redirect( self::getModuleEditPageURL() ); } public static function getModuleEditPageURL( $_aGetQuery=array() ) { return add_query_arg( $_aGetQuery + array( 'page' => TaskScheduler_Registry::AdminPage_EditModule, ), admin_url( 'admin.php' ) ); } public static function goToTaskListingPage() { wp_safe_redirect( self::getTaskListingPageURL() ); } static public function getTaskListingPageURL( array $aQueryArgs=array() ) { return add_query_arg( $aQueryArgs + array( 'page' => TaskScheduler_Registry::AdminPage_TaskList, ), admin_url( 'admin.php' ) ); } }abstract class TaskScheduler_LogUtility_Base extends TaskScheduler_PluginUtility {}abstract class TaskScheduler_LogUtility_Add extends TaskScheduler_LogUtility_Base { static public function log( $iTaskOrLogID, $asLog ) { if ( ! $iTaskOrLogID ) { return 0; } $_sLog = is_array( $asLog ) ? implode( ' ', $asLog ) : $asLog; return TaskScheduler_Registry::PostType_Log == get_post_type( $iTaskOrLogID ) ? self::logByParentLogID( $iTaskOrLogID, $_sLog ) : self::logByTaskID( $iTaskOrLogID, $_sLog ); } static private function logByTaskID( $iTaskID, $sLog ) { return self::_insertLog( array( 'post_content' => $sLog, 'post_excerpt' => $sLog, 'post_status' => 'private', 'post_title' => self::_getExcerpt( $sLog ), 'post_parent' => $iTaskID, '_routine_id' => $iTaskID, ) ); } static private function logByParentLogID( $iParentLogID, $sLog ) { return self::_insertLog( array( 'post_content' => $sLog, 'post_excerpt' => $sLog, 'post_status' => 'private', 'post_title' => self::_getExcerpt( $sLog ), 'post_parent' => $iParentLogID, '_routine_id' => get_post_meta( $iParentLogID, '_routine_id', true ), ) ); } static private function _insertLog( array $aPostArgs ) { $_iLogID = self::insertPost( $aPostArgs, TaskScheduler_Registry::PostType_Log ); wp_update_post( array( 'ID' => $_iLogID, 'post_name' => 'task_scheduler_log_' . $_iLogID ) ); return $_iLogID; } static private function _getExcerpt( $sText, $iMaxChars=250 ) { $_sSubstr = function_exists( 'mb_substr' ) ? 'mb_substr' : 'substr'; $_sStrlen = function_exists( 'mb_strlen' ) ? 'mb_strlen' : 'strlen'; return $_sSubstr( $sText, 0, $iMaxChars ) . ( $_sStrlen( $sText ) > $iMaxChars ? '...' : '' ); } }abstract class TaskScheduler_TaskUtility_Base extends TaskScheduler_PluginUtility {}abstract class TaskScheduler_ThreadUtility_Base extends TaskScheduler_PluginUtility {}abstract class TaskScheduler_LogUtility_Get extends TaskScheduler_LogUtility_Add { static public function find( array $aArgs=array() ) { $_aArgs = $aArgs + array( 'post_type' => TaskScheduler_Registry::PostType_Log, 'post_status' => array( 'publish', 'private' ), 'posts_per_page' => -1, 'orderby' => 'date ID', 'order' => 'DESC', 'fields' => 'ids', ); $_oResults = new WP_Query( $_aArgs ); return $_oResults; } static public function getChildLogs( $iRootLogID ) { return get_children( array( 'post_parent' => $iRootLogID, 'post_type' => TaskScheduler_Registry::PostType_Log, ) ); } static public function getChildLogIDs( $iRootLogID ) { $_aResults = get_children( array( 'post_parent' => $iRootLogID, 'post_type' => TaskScheduler_Registry::PostType_Log, ), 'ARRAY_A' ); return array_values( $_aResults ); } static public function getRootLogIDs( $iTaskID ) { $_aResults = self::find( array( 'order' => 'ASC', 'post_parent' => $iTaskID, ) ); return array_values( $_aResults->posts ); } static public function getRootLogCount( $iTaskID ) { return count( self::getRootLogIDs( $iTaskID ) ); } static public function getLogIDs( $iTaskID ) { $_aResults = self::find( array( 'order' => 'ASC', 'meta_query' => array( array( 'key' => '_routine_id', 'value' => $iTaskID, ), ), ) ); return array_values( $_aResults->posts ); } static public function getLogCount( $iTaskID ) { return count( self::getLogIDs( $iTaskID ) ); } }final class TaskScheduler_LogUtility extends TaskScheduler_LogUtility_Get { static public function deleteChildLogs( $iRootLogID ) { $_iDeleted = 0; foreach( self::getChildLogIDs( $iRootLogID ) as $_iChildLogID ) { if ( ! is_numeric( $_iChildLogID ) ) { continue; } if ( self::doesPostExist( $_iChildLogID ) ) { $_vReturn = wp_delete_post( $_iChildLogID, true ); $_iDeleted = $_vReturn ? ++$_iDeleted : $_iDeleted; } } return $_iDeleted; } }abstract class TaskScheduler_TaskUtility_Edit extends TaskScheduler_TaskUtility_Base { static public function enable( $iTaskID ) { wp_update_post( array( 'ID' => $iTaskID, 'post_status' => 'private', ) ); update_post_meta( $iTaskID, '_routine_status', 'inactive' ); } static public function disable( $iTaskID ) { wp_update_post( array( 'ID' => $iTaskID, 'post_status' => 'pending', ) ); update_post_meta( $iTaskID, '_routine_status', 'inactive' ); } }abstract class TaskScheduler_ThreadUtility_Edit extends TaskScheduler_ThreadUtility_Base { }abstract class TaskScheduler_TaskUtility_Get extends TaskScheduler_TaskUtility_Edit { static public function find( array $aArgs=array() ) { $_aArgs = $aArgs + array( 'post_type' => TaskScheduler_Registry::PostType_Task, 'post_status' => array( 'publish', 'private' ), 'posts_per_page' => -1, 'orderby' => 'date ID', 'order' => 'DESC', 'fields' => 'ids', ); $_oResults = new WP_Query( $_aArgs ); return $_oResults; } static public function hasThreads( $iTaskID, $bExcludeInternals=true ) { return ( self::getThreadCount( $iTaskID, $bExcludeInternals ) > 0 ); } static public function getThreadCount( $iTaskID, $bExcludeInternals=true ) { return TaskScheduler_ThreadUtility::getThreadsByOwnerID( $iTaskID, $bExcludeInternals )->found_posts; } }abstract class TaskScheduler_TaskUtility_Add extends TaskScheduler_TaskUtility_Get { static public $aDefaultMeta = array( '_routine_status' => null, '_next_run_time' => null, '_count_call' => 0, '_count_exit' => 0, '_count_run' => 0, '_count_hung' => 0, 'routine_action' => null, 'argument' => null, 'occurrence' => null, 'log_id' => null, '_max_root_log_count' => 0, '_max_execution_time' => null, ); static public function create( array $aTaskOptions, array $aSystemTaxonomyTerms=array(), $bAllowDuplicate=false ) { if ( ! $bAllowDuplicate && self::hasSameTask( $aTaskOptions, $aSystemTaxonomyTerms ) ) { return 0; } return self::add( $aTaskOptions, $aSystemTaxonomyTerms, $bAllowDuplicate ); } static private function hasSameTask( $aTaskOptions, $aSystemTaxonomyTerms ) { $_aTaskMeta = $aTaskOptions; $_aCheckingTopLevelArguments = array( 'post_title', ); $_aNotCheckingTopLevelArguments = array( 'ID' , 'tax_input', 'post_type', 'post_author', 'post_status', 'post_content' , 'post_name' , 'post_parent' , 'menu_order' , 'ping_status', 'to_ping' , 'pinged' , 'post_password' , 'guid' , 'post_content_filtered' , 'post_excerpt' , 'post_date' , 'post_date_gmt' , 'comment_status' , 'post_category' , 'tags_input' , 'page_template' , ); $_aQueryArguments = array( ); foreach ( $_aCheckingTopLevelArguments as $_sCheckingKey ) { if ( isset( $_aTaskMeta[ $_sCheckingKey ] ) ) { $_aQueryArguments[ $_sCheckingKey ] = $_aTaskMeta[ $_sCheckingKey ]; unset( $_aTaskMeta[ $_sCheckingKey ] ); } } foreach ( $_aNotCheckingTopLevelArguments as $_sCheckingKey ) { unset( $_aTaskMeta[ $_sCheckingKey ] ); } foreach ( $_aTaskMeta as $_sMetaKey => $_vValue ) { if ( is_string( $_vValue ) || is_numeric( $_vValue ) || is_bool( $_vValue ) ) { continue; } unset( $_aTaskMeta[ $_sMetaKey ] ); } $_aMetaQuery = array( 'relation' => 'AND' ); foreach ( $_aTaskMeta as $_sKey => $_vValue ) { $_aMetaQuery[] = array( 'key' => $_sKey, 'value' => $_vValue, 'compare' => 'IN', ); } $_aQueryArguments[ 'meta_query' ] = $_aMetaQuery; $_aQueryArguments[ 'post_status ' ] = 'any'; $_aQueryArguments[ 'posts_per_page' ] = 1; $_aResults = self::find( $_aQueryArguments ); return $_aResults->found_posts ? true : false; } static public function add( array $aTaskOptions, array $aSystemTaxonomyTerms=array() ) { $aTaskOptions = self::uniteArrays( array( '_count_call' => 0, '_count_exit' => 0, '_count_run' => 0, ), $aTaskOptions + array( 'post_status' => 'private', '_routine_status' => 'inactive', 'tax_input' => array( TaskScheduler_Registry::Taxonomy_SystemLabel => $aSystemTaxonomyTerms ), ) ); unset( $aTaskOptions['_is_spawned'], $aTaskOptions['_last_run_time'], $aTaskOptions['_exit_code'] ); $_iTaskID = self::insertPost( $aTaskOptions, TaskScheduler_Registry::PostType_Task ); $_aSystemInternalTerms = isset( $aTaskOptions['tax_input'][ TaskScheduler_Registry::Taxonomy_SystemLabel ] ) ? $aTaskOptions['tax_input'][ TaskScheduler_Registry::Taxonomy_SystemLabel ] : array(); if ( ! empty( $_aSystemInternalTerms ) ) { wp_set_object_terms( $_iTaskID, $_aSystemInternalTerms, TaskScheduler_Registry::Taxonomy_SystemLabel, true ); } return $_iTaskID; } }class TaskScheduler_TaskUtility extends TaskScheduler_TaskUtility_Add {}abstract class TaskScheduler_RoutineUtility_Base extends TaskScheduler_TaskUtility {}abstract class TaskScheduler_ThreadUtility_Get extends TaskScheduler_ThreadUtility_Edit { static public function find( array $aArgs=array() ) { $_aArgs = $aArgs + array( 'post_type' => TaskScheduler_Registry::PostType_Thread, 'post_status' => array( 'publish', 'private' ), 'posts_per_page' => -1, 'orderby' => 'date ID', 'order' => 'DESC', 'fields' => 'ids', ); return new WP_Query( $_aArgs ); } static public function getThreadsByOwnerID( $iOwnerTaskID, $bExcludeInternals=true ) { $_aArgs = array( 'meta_query' => array( array( 'key' => 'owner_routine_id', 'value' => $iOwnerTaskID, ), ), 'tax_query' => array( array( 'taxonomy' => TaskScheduler_Registry::Taxonomy_SystemLabel, 'field' => 'slug', 'terms' => array( 'internal' ), 'operator' => 'NOT IN' ) ), ); if ( ! $bExcludeInternals ) { unset( $_aArgs['tax_query'] ); } return self::find( $_aArgs ); } }abstract class TaskScheduler_ThreadUtility_Add extends TaskScheduler_ThreadUtility_Get { static public $aDefaultMeta = array( '_routine_status' => 'queued', '_next_run_time' => null, 'routine_action' => null, 'occurrence' => 'volatile', 'parent_routine_log_id' => null, 'owner_routine_id' => null, '_max_execution_time' => null, ); static public function create( $iOwnerTaskID, array $aThreadOptions, array $aSystemTaxonomyTerms=array(), $bAllowDuplicate=false ) { if ( ! self::doesPostExist( $iOwnerTaskID ) ) { return 0; } if ( ! $bAllowDuplicate && self::hasSameTask( $aThreadOptions, $aSystemTaxonomyTerms ) ) { return 0; } return self::add( $iOwnerTaskID, $aThreadOptions, $aSystemTaxonomyTerms, $bAllowDuplicate ); } static private function hasSameTask( $aThreadOptions, $aSystemTaxonomyTerms ) { $_aThreadMeta = $aThreadOptions; $_aCheckingTopLevelArguments = array( 'post_title', ); $_aNotCheckingTopLevelArguments = array( 'ID', 'tax_input', 'post_type', 'post_author', 'post_status', 'post_content' , 'post_name' , 'post_parent' , 'menu_order' , 'ping_status', 'to_ping' , 'pinged' , 'post_password' , 'guid' , 'post_content_filtered' , 'post_excerpt' , 'post_date' , 'post_date_gmt' , 'comment_status' , 'post_category' , 'tags_input' , 'page_template' , ); $_aQueryArguments = array(); foreach ( $_aCheckingTopLevelArguments as $_sCheckingKey ) { if ( isset( $_aThreadMeta[ $_sCheckingKey ] ) ) { $_aQueryArguments[ $_sCheckingKey ] = $_aThreadMeta[ $_sCheckingKey ]; unset( $_aThreadMeta[ $_sCheckingKey ] ); } } foreach ( $_aNotCheckingTopLevelArguments as $_sCheckingKey ) { unset( $_aThreadMeta[ $_sCheckingKey ] ); } foreach ( $_aThreadMeta as $_sMetaKey => $_vValue ) { if ( is_string( $_vValue ) || is_numeric( $_vValue ) || is_bool( $_vValue ) ) { continue; } unset( $_aThreadMeta[ $_sMetaKey ] ); } $_aMetaQuery = array( 'relation' => 'AND' ); foreach ( $_aThreadMeta as $_sKey => $_vValue ) { $_aMetaQuery[] = array( 'key' => $_sKey, 'value' => $_vValue, 'compare' => 'IN', ); } $_aQueryArguments[ 'meta_query' ] = $_aMetaQuery; $_aQueryArguments[ 'post_status ' ] = 'any'; $_aQueryArguments[ 'posts_per_page' ] = 1; $_aResults = self::find( $_aQueryArguments ); return $_aResults->found_posts ? true : false; } static public function add( $iOwnerTaskID, array $aThreadOptions=array(), array $aSystemTaxonomyTerms=array() ) { $_oOwnerTask = TaskScheduler_Routine::getInstance( $iOwnerTaskID ); if ( ! is_object( $_oOwnerTask ) ) { return 0; } $aThreadOptions = array( '_routine_status' => 'queued', 'owner_routine_id' => $iOwnerTaskID, '_count_call' => 0, '_count_run' => 0, ) + $aThreadOptions + array( 'post_status' => 'private', '_next_run_time' => microtime( true ), 'tax_input' => array( TaskScheduler_Registry::Taxonomy_SystemLabel => $aSystemTaxonomyTerms ), '_max_execution_time' => $_oOwnerTask->_max_execution_time, ) + self::$aDefaultMeta; unset( $aThreadOptions['_is_spawned'], $aThreadOptions['_last_run_time'], $aThreadOptions['_exit_code'], $aThreadOptions['_count_exit'], $aThreadOptions['_count_hung'] ); if ( ! in_array( $aThreadOptions['occurrence'], array( 'volatile', ) ) ) { return 0; } $_iThreadID = self::insertPost( $aThreadOptions, TaskScheduler_Registry::PostType_Thread ); $_aSystemInternalTerms = isset( $aThreadOptions['tax_input'][ TaskScheduler_Registry::Taxonomy_SystemLabel ] ) ? $aThreadOptions['tax_input'][ TaskScheduler_Registry::Taxonomy_SystemLabel ] : array(); if ( ! empty( $_aSystemInternalTerms ) ) { wp_set_object_terms( $_iThreadID, $_aSystemInternalTerms, TaskScheduler_Registry::Taxonomy_SystemLabel, true ); } return $_iThreadID; } }final class TaskScheduler_ThreadUtility extends TaskScheduler_ThreadUtility_Add {}abstract class TaskScheduler_RoutineUtility_Edit extends TaskScheduler_RoutineUtility_Base {}abstract class TaskScheduler_RoutineUtility_Get extends TaskScheduler_RoutineUtility_Edit { static public function find( array $aArgs=array() ) { $_aArgs = $aArgs + array( 'post_type' => array( TaskScheduler_Registry::PostType_Task, TaskScheduler_Registry::PostType_Thread ), 'post_status' => array( 'publish', 'private' ), 'posts_per_page' => -1, 'orderby' => 'date ID', 'order' => 'DESC', 'fields' => 'ids', ); return new WP_Query( $_aArgs ); } static public function getProcessingCount( $iLimit=-1 ) { return count( self::getProcessing( $iLimit ) ); } static public function getProcessing( $iLimit=-1 ) { $_aArgs = array( 'posts_per_page' => $iLimit, 'meta_query' => array( 'relation' => 'AND', array( 'key' => '_routine_status', 'value' => array( 'processing', 'awaiting' ), 'compare' => 'IN', ), ), ); $_oResults = self::find( $_aArgs ); return $_oResults->posts; } static public function getScheduled( $iSecondsFromNow=30, $iLimit=-1 ) { $_aArgs = array( 'posts_per_page' => $iLimit, 'orderby' => 'meta_value_num', 'meta_key' => '_next_run_time', 'order' => 'ASC', 'meta_query' => array( 'relation' => 'AND', array( 'key' => '_next_run_time', 'value' => array( 0, '' ), 'compare' => 'NOT IN', ), array( 'key' => '_next_run_time', 'value' => microtime( true ) + $iSecondsFromNow, 'type' => 'numeric', 'compare' => '<=', ), array( 'key' => '_is_spawned', 'value' => '_', 'compare' => 'NOT EXISTS', ), ), ); $_oResults = self::find( $_aArgs ); return $_oResults->posts; } }abstract class TaskScheduler_RoutineUtility_Add extends TaskScheduler_RoutineUtility_Get {}class TaskScheduler_RoutineUtility extends TaskScheduler_RoutineUtility_Add {}class TaskScheduler_Event { public function __construct() { new TaskScheduler_Occurrence_FixedInterval( 'fixed_interval', 'TaskScheduler_Occurrence_FixedInterval_Wizard' ); new TaskScheduler_Occurrence_SpecificTime( 'specific_time', 'TaskScheduler_Occurrence_SpecificTime_Wizard' ); new TaskScheduler_Occurrence_ExitCode( 'on_exit_code', 'TaskScheduler_Occurrence_ExitCode_Wizard' ); new TaskScheduler_Occurrence_Volatile( 'volatile' ); new TaskScheduler_Occurrence_Constant( 'constant' ); new TaskScheduler_Action_PostDeleter( 'task_scheduler_action_delete_post', array( 'TaskScheduler_Action_PostDeleter_Wizard', 'TaskScheduler_Action_PostDeleter_Wizard_2', 'TaskScheduler_Action_PostDeleter_Wizard_3' ) ); new TaskScheduler_Action_Debug( 'task_scheduler_action_debug', 'TaskScheduler_Action_Debug_Wizard' ); new TaskScheduler_Action_Email( 'task_scheduler_action_email', 'TaskScheduler_Action_Email_Wizard' ); new TaskScheduler_Action_RoutineLogDeleter( 'task_scheduler_action_delete_task_log' ); new TaskScheduler_Action_HungRoutineHandler_Thread( 'task_scheduler_action_handle_hung_task' ); new TaskScheduler_Event_Routine; new TaskScheduler_Event_Task; new TaskScheduler_Event_Thread; new TaskScheduler_Event_Log; new TaskScheduler_Event_Exit; TaskScheduler_ServerHeartbeat::pulsate(); new TaskScheduler_Event_ServerHeartbeat_Option; new TaskScheduler_Event_ServerHeartbeat_Checker; new TaskScheduler_Event_ServerHeartbeat_Loader; new TaskScheduler_Event_ServerHeartbeat_Resumer; } }class TaskScheduler_Event_Exit { public function __construct() { add_action( 'task_scheduler_action_after_doing_task', array( $this, '_replyToHandleTaskExits' ), 100, 2 ); add_action( 'task_scheduler_action_after_doing_thread', array( $this, '_replyToHandleThreadExits' ), 100, 2 ); } public function _replyToHandleThreadExits( $oThread, $isExitCode ) { if ( ! is_object( $oThread ) ) { return; } if ( has_term( array( 'internal' ), TaskScheduler_Registry::Taxonomy_SystemLabel, $oThread->ID ) ) { return; } $this->_doExitCode( $isExitCode, $oThread ); $_oTask = $oThread->getOwner(); if ( ! is_object( $_oTask ) ) { return; } if ( 1 < $_oTask->getThreadCount() ) { return; } $this->_doTasksOnExitCode( $isExitCode, $_oTask ); } public function _replyToHandleTaskExits( $oRoutine, $isExitCode ) { $this->_doExitCode( $isExitCode, $oRoutine ); $this->_doTasksOnExitCode( $isExitCode, $oRoutine ); } private function _doExitCode( $isExitCode, $oRoutine ) { if ( 'DELETE' === $isExitCode ) { $oRoutine->delete(); } } private function _doTasksOnExitCode( $isExitCode, $oRoutine ) { $_aFoundTasks = $this->_getTasksOnExitCode( $isExitCode, $oRoutine->ID ); foreach( $_aFoundTasks as $_iTaskID ) { do_action( 'task_scheduler_action_spawn_routine', $_iTaskID, microtime( true ) ); } } private function _getTasksOnExitCode( $isExitCode, $iSubjectRoutineID ) { $_oResult = TaskScheduler_TaskUtility::find( array( 'post__not_in' => array( $iSubjectRoutineID ), 'meta_query' => array( array( 'key' => 'occurrence', 'value' => 'on_exit_code', ), array( 'key' => '__on_exit_code', 'value' => $isExitCode, ), array( 'key' => '__on_exit_code_task_ids', 'value' => ':' . $iSubjectRoutineID . ';', 'compare' => 'LIKE', ), ) ) ); return $_oResult->posts; } }class TaskScheduler_Event_Log { public function __construct() { add_action( 'before_delete_post', array( $this, '_replyToDeleteLog' ) ); add_action( 'task_scheduler_action_add_log_deletion_task', array( $this, '_replyToAddLogDeletionTask' ) ); } public function _replyToDeleteLog( $iPostID ) { if ( TaskScheduler_Registry::PostType_Task != get_post_type( $iPostID ) ) { return; } if ( has_term( array( 'delete_log' ), TaskScheduler_Registry::Taxonomy_SystemLabel, $iPostID ) ) { return; } if ( ! TaskScheduler_LogUtility::getLogCount( $iPostID ) ) { return; } $this->_addLogDeleteTask( $iPostID, 0 ); } public function _replyToAddLogDeletionTask( $ioTask ) { $_oTask = is_object( $ioTask ) ? $ioTask : TaskScheduler_Routine::getInstance( $ioTask ); if ( is_object( $_oTask ) ) { $this->_addLogDeleteTask( $_oTask->ID, $_oTask->_max_root_log_count ); } } private function _addLogDeleteTask( $iTargetTaskID, $iMaxRootLogCountOfTheSubjectTask=0 ) { $_iTaskID = TaskScheduler_TaskUtility::create( array( 'post_title' => sprintf( __( 'Delete Logs of %1$s' ), $iTargetTaskID ), 'post_excerpt' => sprintf( __( 'Deletes the logs of the task %1$s. This task will be gone when unnecessary logs are deleted.' ), $iTargetTaskID ), 'routine_action' => 'task_scheduler_action_delete_task_log', 'occurrence' => 'constant', '_max_root_log_count' => 0, '_target_routine_id' => $iTargetTaskID, '_max_root_log_count_of_the_target' => $iMaxRootLogCountOfTheSubjectTask, ), array( 'system', 'delete_log' ) ); if ( $_iTaskID ) { $_oTask = TaskScheduler_Routine::getInstance( $_iTaskID ); $_oTask->setNextRunTime(); do_action( 'task_scheduler_action_check_shceduled_actions' ); } } }class TaskScheduler_Event_Routine { public function __construct() { add_action( 'task_scheduler_action_before_calling_routine', array( $this, '_replyToSpawnRoutine' ), 10, 2 ); add_action( 'task_scheduler_action_cancel_routine', array( $this, '_replyToCancelRoutine' ) ); add_action( 'task_scheduler_action_before_doing_routine', array( $this, '_replyToDoBeforeRoutine' ) ); add_action( 'task_scheduler_action_do_routine', array( $this, '_replyToDoRoutine' ), 10, 2 ); add_action( 'task_scheduler_action_after_doing_routine', array( $this, '_replyToCompleteRoutine' ) ); } public function _replyToSpawnRoutine( $oRoutine, $nSpawnedTime ) { if ( ! is_object( $oRoutine ) ) { return; } $oRoutine->deleteMeta( '_eixt_code' ); $_sPreviousTaskStatus = $oRoutine->_routine_status; $_iMaxTaskExecutionTime = ( int ) $oRoutine->_max_execution_time; $_sLoadID = TaskScheduler_Registry::TransientPrefix . md5( $nSpawnedTime ); set_transient( $_sLoadID, $_sPreviousTaskStatus, $_iMaxTaskExecutionTime ? $_iMaxTaskExecutionTime : 30 ); $oRoutine->setMeta( '_routine_status', 'awaiting' ); $oRoutine->setMeta( '_is_spawned', true ); $oRoutine->setMeta( '_spawned_time', $nSpawnedTime ); $oRoutine->setMeta( '_count_call', $oRoutine->getMeta( '_count_call' ) + 1 ); if ( $oRoutine->isTask() ) { do_action( 'task_scheduler_action_add_hung_routine_handler_thread', $oRoutine ); } } public function _replyToCancelRoutine( $oRoutine ) { $_nSpawnedMicrotime = $oRoutine->getMeta( '_spawned_time' ); $_sTransientKey = TaskScheduler_Registry::TransientPrefix . md5( $_nSpawnedMicrotime ); $_sPreviousTaskStatus = get_transient( $_sTransientKey ); if ( $_sPreviousTaskStatus ) { $oRoutine->setMeta( '_routine_status', $_sPreviousTaskStatus ); } $oRoutine->deleteMeta( '_is_spawned' ); delete_transient( $_sTransientKey ); } public function _replyToDoBeforeRoutine( $oRoutine ) { $oRoutine->setMeta( '_routine_status', 'processing' ); $oRoutine->setMeta( '_last_run_time', microtime( true ) ); $oRoutine->deleteMeta( '_is_spawned' ); } public function _replyToDoRoutine( $oRoutine, $nNextScheduledTime=0 ) { $_bIsThread = $oRoutine->isThread(); $_sThreadOrTask = $_bIsThread ? 'thread' : 'task'; $_iLogID = $oRoutine->log( $this->_getLogText( $oRoutine ), 0, true ); do_action( "task_scheduler_action_before_doing_{$_sThreadOrTask}" , $oRoutine ); if ( ! $nNextScheduledTime ) { $oRoutine->setMeta( '_next_run_time', apply_filters( "task_scheduler_filter_next_run_time_{$oRoutine->occurrence}", '', $oRoutine ) ); } $oRoutine->_exit_code = apply_filters( $oRoutine->routine_action, null, $oRoutine ); do_action( "task_scheduler_action_after_doing_{$_sThreadOrTask}", $oRoutine, $oRoutine->_exit_code ); do_action( "task_scheduler_action_after_doing_routine_of_occurrence_{$oRoutine->occurrence}", $oRoutine, $oRoutine->_exit_code ); } private function _getLogText( $oRoutine ) { $_aLogs = array(); $_aLogs[] = $oRoutine->isThread() ? __( 'Starting the thread.', 'task-scheduler' ) : __( 'Starting the task.', 'task-scheduler' ); $_aLogs[] = __( 'ID', 'task-scheduler' ) . ': ' . $oRoutine->ID; $_aLogs[] = __( 'Action', 'task-scheduler' ) . ': ' . apply_filters( "task_scheduler_filter_label_action_{$oRoutine->routine_action}", $oRoutine->routine_action ); return $_aLogs; } public function _replyToCompleteRoutine( $oRoutine ) { $oRoutine->setMeta( '_count_run', $oRoutine->_count_run + 1 ); $_nSpawnedMicrotime = $oRoutine->getMeta( '_spawned_time' ); $_sTransientKey = TaskScheduler_Registry::TransientPrefix . md5( $_nSpawnedMicrotime ); delete_transient( $_sTransientKey ); } }class TaskScheduler_Event_Task { public function __construct() { add_action( 'task_scheduler_action_before_doing_task', array( $this, '_replyToStartTask' ), 1 ); add_action( 'task_scheduler_action_after_doing_task', array( $this, '_replyToCompleteTask' ), 10, 2 ); } public function _replyToStartTask( $oTask ) {} public function _replyToCompleteTask( $oTask, $sExitCode ) { $_bHasThreads = $oTask->hasThreads(); if ( null !== $sExitCode ) { $oTask->setMeta( '_exit_code', $sExitCode ); $oTask->setMeta( '_count_exit', ( int ) $oTask->getMeta( '_count_exit' ) + 1 ); } if ( ! $_bHasThreads ) { $oTask->setMeta( '_routine_status', 'inactive' ); $oTask->deleteMeta( '_spawned_time' ); } $oTask->log( $this->_getLogText( $_bHasThreads, $sExitCode ), $oTask->log_id ); if ( $oTask->getRootLogCount() > ( int ) $oTask->_max_root_log_count ) { do_action( 'task_scheduler_action_add_log_deletion_task', $oTask ); } $_iHeartbeatInterval = ( int ) TaskScheduler_Option::get( array( 'server_heartbeat', 'interval' ) ); $_nSum = microtime( true ) + $_iHeartbeatInterval; if ( $_nSum > $oTask->_next_run_time ) { do_action( 'task_scheduler_action_check_shceduled_actions' ); } } private function _getLogText( $bHasThreads, $sExitCode ) { $_aLog = array(); if ( $bHasThreads ) { $_aLog[] = __( 'Still have threaded tasks.', 'task-scheduler' ); $_sLog[] = null !== $sExitCode ? ' ' . __( 'Exit Code', 'task-scheduler' ) . ': ' . $sExitCode : ''; return $_aLog; } $_aLog[] = null !== $sExitCode ? __( 'Completed the task.', 'task-scheduler' ) . ' ' . __( 'Exit Code', 'task-scheduler' ) . ': ' . $sExitCode : __( 'The task did not return an exit code.', 'task-scheduler' ); return $_aLog; } }class TaskScheduler_Event_Thread { public function __construct() { add_action( 'task_scheduler_action_before_doing_thread', array( $this, '_replyToStartThread' ), 1 ); add_action( 'task_scheduler_action_after_doing_thread', array( $this, '_replyToCompleteThread' ), 10, 2 ); } public function _replyToStartThread( $oTask ) { } public function _replyToCompleteThread( $oThread, $isExitCode ) { if ( ! is_object( $oThread ) ) { return; } $oThread->setMeta( '_routine_status', 'queued' ); $_oTask = $oThread->getOwner(); if ( ! is_object( $_oTask ) ) { return; } if ( has_term( array( 'internal' ), TaskScheduler_Registry::Taxonomy_SystemLabel, $oThread->ID ) ) { return; } $_oTask->log( sprintf( __( 'Finished the thread: %1$s', 'task-scheduler' ), $oThread->ID ), $oThread->parent_routine_log_id ); if ( 'NOT_DELETE' === $isExitCode ) { return; } if ( 1 < $_oTask->getThreadCount() ) { return; } $_oTask->setMeta( '_routine_status', 'inactive' ); $_oTask->setMeta( '_exit_code', $isExitCode ); $_oTask->setMeta( '_count_exit', $_oTask->_count_exit + 1 ); $oThread->deleteMeta( '_spawned_time' ); $_oTask->log( __( 'Completed all the threads.', 'task-scheduler' ) . ' ' . sprintf( __( 'Exit Code: %1$s', 'task-scheduler' ), $isExitCode ), $oThread->parent_routine_log_id ); } }class TaskScheduler_Event_ServerHeartbeat_Checker { static public $sCheckActionTransientKey = 'TS_checking_actions'; static public $sRecheckActionTransientKey = 'TS_rechecking_actions'; public function __construct() { add_action( 'task_scheduler_action_spawn_routine', array( $this, '_replyToSpawnRoutine' ), 10, 2 ); add_action( 'task_scheduler_action_check_shceduled_actions', array( $this, '_replyToCheckScheduledActions' ) ); if ( isset( $_COOKIE[ 'server_heartbeat_action' ] ) ) { return; } if ( isset( $GLOBALS['pagenow'] ) && in_array( $GLOBALS['pagenow'], array( 'admin-ajax.php', ) ) ) { return; } if ( ! ( TaskScheduler_ServerHeartbeat::isBackground() || $this->_isManualPageLoad() ) ) { return; } if ( TaskScheduler_WPUtility::getTransientWithoutCache( self::$sCheckActionTransientKey ) ) { return; } add_action( 'wp_loaded', array( $this, '_replyToSpawnRoutines' ), 1 ); return; } private function _isManualPageLoad() { if ( isset( $GLOBALS['pagenow'] ) && in_array( $GLOBALS['pagenow'], array( 'wp-cron.php' ) ) ) { return false; } if ( TaskScheduler_Option::get( array( 'server_heartbeat', 'power' ) ) ) { return false; } return isset( $_REQUEST['task_scheduler_checking_actions'] ) && $_REQUEST['task_scheduler_checking_actions']; } public function _replyToSpawnRoutines() { $_iSecondsFromNow = TaskScheduler_Utility::canUseIniSet() ? TaskScheduler_Option::get( array( 'server_heartbeat', 'interval' ) ) : 0; $_iMaxAllowedNumberOfRoutines = TaskScheduler_Option::get( array( 'routine', 'max_background_routine_count' ) ); $_aScheduledRoutines = TaskScheduler_RoutineUtility::getScheduled( $_iSecondsFromNow, $_iMaxAllowedNumberOfRoutines ); $_iProcessingCount = TaskScheduler_RoutineUtility::getProcessingCount(); $_iAllowedNumberOfRoutines = $_iMaxAllowedNumberOfRoutines - $_iProcessingCount; $_aScheduledRoutines = array_slice( $_aScheduledRoutines, 0, $_iAllowedNumberOfRoutines ); $_nNow = microtime( true ); delete_transient( self::$sRecheckActionTransientKey ); set_transient( self::$sCheckActionTransientKey, $_nNow, 60 ); foreach ( $_aScheduledRoutines as $_iRoutineID ) { $_oTask = TaskScheduler_Routine::getInstance( $_iRoutineID ); if ( ! is_object( $_oTask ) ) { continue; } if ( ! $_oTask->_force_execution && ! in_array( $_oTask->_routine_status, array( 'inactive', 'queued' ) ) ) { continue; } if ( $_oTask->isThread() && ! is_object( TaskScheduler_Routine::getInstance( $_oTask->owner_routine_id ) ) ) { $_oTask->delete(); continue; } do_action( 'task_scheduler_action_spawn_routine', $_iRoutineID ); } delete_transient( self::$sCheckActionTransientKey ); if ( TaskScheduler_WPUtility::getTransientWithoutCache( self::$sRecheckActionTransientKey ) ) { delete_transient( self::$sRecheckActionTransientKey ); TaskScheduler_ServerHeartbeat::beat(); } } public function _replyToSpawnRoutine( $iRoutineID, $nScheduledTime=null ) { $_nCurrentMicrotime = microtime( true ); do_action( 'task_scheduler_action_before_calling_routine', TaskScheduler_Routine::getInstance( $iRoutineID ), $_nCurrentMicrotime ); $_aDebugInfo = defined( 'WP_DEBUG' ) && WP_DEBUG ? array( 'spawning_routine' => $iRoutineID ) : array(); TaskScheduler_ServerHeartbeat::loadPage( add_query_arg( $_aDebugInfo, trailingslashit( site_url() ) ), array( 'server_heartbeat_id' => '', 'server_heartbeat_action' => $iRoutineID, 'server_heartbeat_scheduled_time' => $nScheduledTime, 'server_heartbeat_spawned_time' => $_nCurrentMicrotime, ), 'spawn_routine' ); } public function _replyToCheckScheduledActions() { if ( get_transient( self::$sCheckActionTransientKey ) ) { set_transient( self::$sRecheckActionTransientKey, microtime( true ), 60 ); return; } TaskScheduler_ServerHeartbeat::beat(); } }class TaskScheduler_Event_ServerHeartbeat_Loader { private $_sTransientPrefix = ''; public function __construct() { $this->_sTransientPrefix = TaskScheduler_Registry::TransientPrefix; if ( ! self::isCallingAction() ) { return; } if ( ! defined( 'DOING_CRON' ) ) { define( 'DOING_CRON', true ); } ignore_user_abort( true ); add_action( 'init', array( $this, '_replyToDoRoutineAndExit' ), 9999 ); } public function _replyToDoRoutineAndExit() { $_oRoutine = TaskScheduler_Routine::getInstance( $_COOKIE['server_heartbeat_action'] ); if ( ! is_object( $_oRoutine ) || ! $_oRoutine->routine_action ) { exit(); } $_nSpawnedTime = isset( $_COOKIE['server_heartbeat_spawned_time'] ) ? $_COOKIE['server_heartbeat_spawned_time'] : null; if ( $_nSpawnedTime !== $_oRoutine->_spawned_time ) { exit(); } do_action( 'task_scheduler_action_after_calling_routine', $_oRoutine ); $this->_doRoutine( $_oRoutine, isset( $_COOKIE['server_heartbeat_scheduled_time'] ) ? $_COOKIE['server_heartbeat_scheduled_time'] : null ); exit(); } private function _doRoutine( $oRoutine, $nScheduledTime=null ) { $_nSleepSeconds = $this->_getRequiredSleepSeconds( $nScheduledTime ? $nScheduledTime : ( int ) $oRoutine->_next_run_time ); $_iActionLockDuration = $this->_setMaxExecutionTime( $oRoutine, $_nSleepSeconds ); $this->_sleep( $_nSleepSeconds ); $_sActionLockKey = $this->_sTransientPrefix . $oRoutine->ID; if ( get_transient( $_sActionLockKey ) ) { do_action( "task_scheduler_action_cancel_routine" , $oRoutine ); return; } do_action( "task_scheduler_action_before_doing_routine", $oRoutine ); set_transient( $_sActionLockKey, time(), $_iActionLockDuration ); do_action( "task_scheduler_action_do_routine" , $oRoutine, $nScheduledTime ); delete_transient( $_sActionLockKey ); do_action( "task_scheduler_action_after_doing_routine", $oRoutine ); } private function _getRequiredSleepSeconds( $nNextRunTimeStamp ) { $_nSleepSeconds = ( $nNextRunTimeStamp - microtime( true ) ) + 0; $_nSleepSeconds = $_nSleepSeconds <= 0 ? 0 : $_nSleepSeconds; return $_nSleepSeconds; } private function _setMaxExecutionTime( $oRoutine, $nSecondsToSleep ){ $_iExpectedTaskExecutionTime = ( int ) $oRoutine->_max_execution_time ? $oRoutine->_max_execution_time : 30; $_nElapsedSeconds = timer_stop( 0, 6 ); $_nRequiredExecutionDuration = ceil( $nSecondsToSleep ) + $_nElapsedSeconds + $_iExpectedTaskExecutionTime; if ( ! TaskScheduler_Utility::canUseIniSet() ) { return $_iExpectedTaskExecutionTime; } $_iServerAllowedMaxExecutionTime = TaskScheduler_Utility::getServerAllowedMaxExecutionTime( 30 ); if ( 0 === $_iServerAllowedMaxExecutionTime || '0' === $_iServerAllowedMaxExecutionTime ) { return $_iExpectedTaskExecutionTime; } if ( 0 === $oRoutine->_max_execution_time || '0' === $oRoutine->_max_execution_time ) { @ini_set( 'max_execution_time', 0 ); } if ( $_nRequiredExecutionDuration > $_iServerAllowedMaxExecutionTime ) { @ini_set( 'max_execution_time', $_nRequiredExecutionDuration ); } return $_iExpectedTaskExecutionTime; } private function _sleep( $nSleepSeconds ) { if ( $nSleepSeconds <= 0 ) { return; } $_iSleepDurationMicroSeconds = ceil( $nSleepSeconds ) * 1000000; if ( $_iSleepDurationMicroSeconds > 0 ) { usleep( $_iSleepDurationMicroSeconds ); } } static public function isCallingAction() { return isset( $_COOKIE[ 'server_heartbeat_action' ] ); } }class TaskScheduler_Event_ServerHeartbeat_Option { public function __construct() { add_filter( 'task_scheduler_filter_serverheartbeat_interval', array( $this, '_replyToModifyServerHeartbeatInterval' ) ); add_filter( 'task_scheduler_filter_serverheartbeat_target_url', array( $this, '_replyToModifyServerHeartbeatTargetURL' ), 10, 2 ); add_filter( 'task_scheduler_filter_serverheartbeat_power', array( $this, '_replyToReturnServerHeartbeatPoswerStatus' ) ); } public function _replyToReturnServerHeartbeatPoswerStatus( $bIsEnabled ) { return TaskScheduler_Option::get( array( 'server_heartbeat', 'power' ) ); } public function _replyToModifyServerHeartbeatInterval( $iInterval ) { $_bPowered = TaskScheduler_Option::get( array( 'server_heartbeat', 'power' ) ); return $_bPowered ? TaskScheduler_Option::get( array( 'server_heartbeat', 'interval' ) ) : 0; } public function _replyToModifyServerHeartbeatTargetURL( $sURL, $sContext ) { if ( ! in_array( $sContext, array( 'start', 'pulsate', 'beat', 'spawn_routine' ) ) ) { return $sURL; } $_bEmbedQueryKey = TaskScheduler_Option::get( array( 'server_heartbeat', 'query_string', 0 ) ); $_sQueryKey = TaskScheduler_Option::get( array( 'server_heartbeat', 'query_string', 1 ) ); $_iCurrentMicrotime = microtime( true ); $_aEmbedQueryKeys = $_bEmbedQueryKey && $_sQueryKey ? array( $_sQueryKey => $_iCurrentMicrotime, 'context' => $sContext, 'last_beat_time' => TaskScheduler_ServerHeartbeat::getLastBeatTime(), ) : array(); return add_query_arg( $_aEmbedQueryKeys, $_bEmbedQueryKey ? $sURL : site_url() ); } }class TaskScheduler_Event_ServerHeartbeat_Resumer { public function __construct() { add_action( 'task_scheduler_action_check_heartbeat_hourly', array( $this, 'task_scheduler_action_check_heartbeat_hourly' ) ); } public function task_scheduler_action_check_heartbeat_hourly() { $this->resume(); } static public function resume() { $_bIsEnabled = TaskScheduler_Option::get( array( 'server_heartbeat', 'power' ), true ) ; if ( ! $_bIsEnabled ) { return; } $_bIsAlive = TaskScheduler_ServerHeartbeat::isAlive(); if ( $_bIsAlive ) { return; } TaskScheduler_ServerHeartbeat::run(); } }final class TaskScheduler_ServerHeartbeat { static public $sTransientKey = 'TS_server_heartbeat'; static public $sTransientKey_Sleep = 'TS_server_heartbeat_sleep'; static public $sServerHeartbeatActionHook = 'task_scheduler_action_check_server_heartbeat'; static private $_bStop = false; static public function getID() { return isset( $_COOKIE{'server_heartbeat_id'} ) ? $_COOKIE{'server_heartbeat_id'} : ''; } static public function isBackground() { return self::getID() ? true : false; } static public function isSleeping() { return ( false !== get_transient( self::$sTransientKey_Sleep ) ); } static public function isAlive() { if ( wp_next_scheduled( self::$sServerHeartbeatActionHook ) ) { return true; } if ( self::isSleeping() ) { return true; } $_iLastBeatTime = self::getLastBeatTime(); $_iInterval = self::getInterval(); $_bIsAlive = ( $_iLastBeatTime + $_iInterval > microtime( true ) ); return $_bIsAlive; } static public function getNextCheckTime() { return wp_next_scheduled( self::$sServerHeartbeatActionHook ); } static public function getLastBeatTime() { return self::_getInfo( 'last_beat_time' ); } static public function getInterval() { static $_iCached; $_iCached = isset( $_iCached ) ? $_iCached : ( int ) self::_getInfo( 'interval' ); return ( int ) apply_filters( 'task_scheduler_filter_serverheartbeat_interval', $_iCached ); } static private function _getInfo( $sKey='' ) { $_aInfo = get_transient( self::$sTransientKey ); if ( false === $_aInfo ) { return false; } $_aInfo = is_array( $_aInfo ) ? $_aInfo : array(); if ( ! $sKey ) { return $_aInfo; } return isset( $_aInfo[ $sKey ] ) ? $_aInfo[ $sKey ] : null; } static private function _saveInfo( array $aSettings=array() ) { $_aInfo = array( 'interval' => self::getInterval(), ) + ( array ) self::_getInfo(); if ( self::isBackground() ) { $_aInfo['second_last_beat_time'] = isset( $_aInfo['last_beat_time'] ) ? $_aInfo['last_beat_time'] : null; $_aInfo['last_beat_time'] = microtime( true ); $_aInfo['id'] = self::getID(); } $_aInfo = $aSettings + array_filter( $_aInfo ); set_transient( self::$sTransientKey, $_aInfo ); } static public function run( $aSettings=array() ) { $_bIsAlive = self::isAlive(); self::_saveInfo( $aSettings ); self::_scheduleToCheckBeat(); if ( $_bIsAlive ) { return false; } add_action( 'shutdown', array( get_class(), '_replyToStart' ) ); return true; } static public function _replyToStart() { static $_bIsCalled; if ( $_bIsCalled ) { return; } $_bIsCalled = true; self::loadPage( '', array(), 'start' ); } static public function stop() { self::$_bStop = true; delete_transient( self::$sTransientKey ); delete_transient( self::$sTransientKey_Sleep ); $_iTimestamp = wp_next_scheduled( self::$sServerHeartbeatActionHook ); if ( $_iTimestamp ) { wp_unschedule_event( $_iTimestamp, self::$sServerHeartbeatActionHook ); } } static public function beat() { add_action( 'shutdown', array( get_class(), '_replyToBeat' ) ); } static public function _replyToBeat() { static $_bIsLoaded = false; if ( $_bIsLoaded ) { return; } $_bIsLoaded = true; self::loadPage( '', array(), 'beat' ); } static public function pulsate() { $_sClassName = get_class(); if ( ! self::isBackground() ) { add_action( self::$sServerHeartbeatActionHook, array( $_sClassName, '_replyToCheck' ) ); return; } if ( ! defined( 'DOING_CRON' ) ) { define( 'DOING_CRON', true ); } ignore_user_abort( true ); if ( self::isSleeping() ) { return; } if ( false === self::_getInfo() ) { self::stop(); return; } self::_saveInfo(); add_action( 'wp_loaded', array( $_sClassName, '_replyToSleepAndExit' ), 20 ); } static public function _replyToCheck() { if ( ! self::getInterval() ) { return; } self::run(); } static public function _replyToSleepAndExit() { $_iInterval = self::getInterval(); $_iReservedSeconds = 3; $_nElapsedTime = timer_stop( 0, 6 ); $_nSleepDuration = ( $_iInterval - $_nElapsedTime ) < 0 ? 0 : $_iInterval - $_nElapsedTime; $_iMaxExecutionTime = function_exists( 'ini_get' ) ? ini_get( 'max_execution_time' ) : 25; $_iSecondsToLimit = $_iMaxExecutionTime - ceil( $_nElapsedTime ); $_nEstimatedRequiredTime = $_nSleepDuration + $_iReservedSeconds; if ( $_iSecondsToLimit < $_nEstimatedRequiredTime ) { if ( function_exists( 'ini_set' ) ) { @ini_set( 'max_execution_time', ceil( $_nEstimatedRequiredTime + $_nElapsedTime ) + 10 ); } else { $_nSleepDuration = $_iSecondsToLimit - $_iReservedSeconds; } } self::_sleep( $_nSleepDuration ); self::_pulsate(); exit(); } static private function _sleep( $nSleepDuration ) { if ( $nSleepDuration <= 0 ) { return; } $_iTransientDuration = ( int ) floor( $nSleepDuration ); if ( $_iTransientDuration ) { set_transient( self::$sTransientKey_Sleep, self::getID(), $_iTransientDuration ); } usleep( $nSleepDuration * 1000000 ); if ( $_iTransientDuration ) { self::_deleteSleepTransient(); } } static private function _deleteSleepTransient() { $_sSleepID = self::_getSleepLock(); if ( false !== $_sSleepID && self::getID() !== $_sSleepID ) { self::$_bStop = true; return; } delete_transient( self::$sTransientKey_Sleep ); } static private function _getSleepLock() { if ( wp_using_ext_object_cache() ) { return wp_cache_get( self::$sTransientKey_Sleep, 'transient', true ); } global $wpdb; $_oRow = $wpdb->get_row( $wpdb->prepare( "SELECT option_value FROM $wpdb->options WHERE option_name = %s LIMIT 1", '_transient_' . self::$sTransientKey_Sleep ) ); return is_object( $_oRow ) ? $_oRow->option_value: false; } static private function _pulsate() { if ( self::$_bStop ) { return; } static $_bIsCalled; if ( $_bIsCalled ) { return; } $_bIsCalled = true; self::_scheduleToCheckBeat(); self::loadPage(); } static private function _scheduleToCheckBeat() { if ( self::$_bStop ) { return; } if ( wp_next_scheduled( self::$sServerHeartbeatActionHook ) ) { return; } wp_schedule_single_event( time() + self::getInterval() + 1, self::$sServerHeartbeatActionHook ); } static public function loadPage( $sTargetURL='', $aCookies=array(), $sContext='pulsate' ) { $_sID = self::getID(); $_sID = $_sID ? $_sID : uniqid(); $sTargetURL = apply_filters( 'task_scheduler_filter_serverheartbeat_target_url', $sTargetURL ? $sTargetURL : add_query_arg( array( 'doing_server_heartbeat' => microtime( true ), 'id' => $_sID, 'context' => $sContext ), trailingslashit( site_url() ) ), $sContext ); $aCookies = $aCookies + array( 'server_heartbeat_id' => $_sID, 'server_heartbeat_context' => $sContext, ); $aCookies = apply_filters( 'task_scheduler_filter_serverheartbeat_cookies', $aCookies, $sContext ); wp_remote_get( $sTargetURL, array( 'timeout' => 0.01, 'sslverify' => false, 'cookies' => $aCookies, ) ); } }abstract class TaskScheduler_Module_Factory { protected $sSlug = ''; protected $_sModuleType = ''; public $aWizardScreens = array(); public function __construct( $sSlug='', $asWizardClasses=array(), $sModuleType='' ) { $this->sSlug = $sSlug ? sanitize_key( $sSlug ) : sanitize_key( $this->sSlug ); $this->_sModuleType = $sModuleType ? $sModuleType : $this->_sModuleType; $this->_sClassName = get_class( $this ); add_filter( "task_scheduler_filter_label_" . $this->_sModuleType . "_" . $this->sSlug, array( $this, 'getLabel' ) ); add_filter( "task_scheduler_filter_description_" . $this->_sModuleType . "_" . $this->sSlug, array( $this, 'getDescription' ) ); if ( is_admin() && isset( $_GET['page'] ) && in_array( $_GET['page'], array( TaskScheduler_Registry::AdminPage_AddNew, TaskScheduler_Registry::AdminPage_EditModule ) ) ) { add_filter( 'task_scheduler_admin_filter_wizard_options', array( $this, '_replyToModifyDefaultOptions' ), 20, 1 ); add_filter( "task_scheduler_admin_filter_wizard_options_{$this->sSlug}", array( $this, '_replyToGetWizardOptions' ) ); add_filter( "task_scheduler_admin_filter_wizard_slugs_{$this->sSlug}", array( $this, '_replyToGetWizardSlugs' ) ); $_aWizardClasses = is_array( $asWizardClasses ) ? $asWizardClasses : array( $asWizardClasses ); foreach( $_aWizardClasses as $_sWizardClass ) { $this->addWizardScreen( $_sWizardClass, $this->sSlug ); } } $this->construct(); } public function _replyToGetWizardSlugs( $aSlugs ) { return $this->getWizardScreenSlugs( $aSlugs ); } public function _replyToGetWizardOptions( array $aSubmit ) { $_aWizardOptions = apply_filters( 'task_scheduler_admin_filter_get_wizard_options', array() ); $_aWizardSlugs = array_reverse( $this->getWizardScreenSlugs() ); foreach( $_aWizardSlugs as $_sSlug ) { if ( isset( $_aWizardOptions[ $_sSlug ] ) && is_array( $_aWizardOptions[ $_sSlug ] ) ) { $aSubmit = $aSubmit + $_aWizardOptions[ $_sSlug ]; } } return $aSubmit; } public function _replyToModifyDefaultOptions( $aOptions ) { $_aWizardSlugs = array_reverse( $this->getWizardScreenSlugs() ); $_aModuleWizardOptions = array(); foreach( $_aWizardSlugs as $_sSlug ) { if ( isset( $aOptions[ $_sSlug ] ) ) { $_aModuleWizardOptions = $aOptions[ $_sSlug ] + $_aModuleWizardOptions; } } foreach( $_aWizardSlugs as $_sSlug ) { if ( isset( $aOptions[ $_sSlug ] ) ) { $aOptions[ $_sSlug ] = $_aModuleWizardOptions; } } return $aOptions; } private function getWizardScreenSlugs( $aSlugs=array() ) { foreach( $this->aWizardScreens as $_aWizardScreen ) { $aSlugs[] = $_aWizardScreen['slug']; } return array_unique( $aSlugs ); } public function addWizardScreen( $sWizardClassName, $sSlug='' ) { if ( ! class_exists( $sWizardClassName ) ) { return; } $_bIsFirst = empty( $this->aWizardScreens ); $_iNth = count( $this->aWizardScreens ) + 1; $_sMainWizardSlug = $this->_getMainWizardSlug( $sSlug ); $sSlug = $_bIsFirst ? $sSlug : $_sMainWizardSlug . '_' . $_iNth; $_oWizardScreen = new $sWizardClassName( $sSlug, $_sMainWizardSlug ); $this->aWizardScreens[] = array( 'class_name' => $sWizardClassName, 'slug' => $sSlug, 'instance' => $_oWizardScreen, 'is_main' => $_bIsFirst, ); if ( $_bIsFirst ) { return; } $_oWizardScreen->bAddToLabelList = false; $_oWizardScreen->sMainWizardSlug = $_sMainWizardSlug; $_oPreviousWizardScreen = isset( $this->aWizardScreens[ $_iNth - 2 ] ) ? $this->aWizardScreens[ $_iNth - 2 ][ 'instance' ] : null; if ( is_object( $_oPreviousWizardScreen ) ) { $_oPreviousWizardScreen->sNextTabSlug = $sSlug; } } private function _getMainWizardSlug( $sDefault ) { foreach( $this->aWizardScreens as $_aWizard ) { if ( $_aWizard['is_main'] ) { return $_aWizard['slug']; } } return $sDefault; } public function getLabel( $sSlug ) { return $this->sSlug; } public function getDescription( $sDescription ) { return $sDescription; } public function construct() {} }abstract class TaskScheduler_Action_Base extends TaskScheduler_Module_Factory { public function __construct( $sSlug, $asWizardClasses=array() ) { parent::__construct( $sSlug, $asWizardClasses, 'action' ); if ( ! $sSlug ) { return; } add_filter( $sSlug, array( $this, 'doAction' ), 10, 3 ); } public function doAction( $isExitCode, $oRoutine ) {} }abstract class TaskScheduler_Occurrence_Base extends TaskScheduler_Module_Factory { public function __construct( $sSlug, $asWizardClasses=array() ) { parent::__construct( $sSlug, $asWizardClasses, 'occurrence' ); add_filter( "task_scheduler_filter_next_run_time_{$sSlug}", array( $this, 'getNextRunTime' ), 10, 2 ); add_action( "task_scheduler_action_after_doing_routine_of_occurrence_{$sSlug}", array( $this, 'doAfterAction' ), 10, 2 ); } public function getNextRunTime( $iTimestamp, $oTask ) { return $iTimestamp; } public function doAfterAction( $oTask, $sExitCode ) {} }class TaskScheduler_Action_Debug extends TaskScheduler_Action_Base { public function construct() {} public function getLabel( $sLabel ) { return __( 'Debug', 'task-scheduler' ); } public function getDescription( $sDescription ) { return __( 'Creates a log file in the wp-content folder.', 'task-scheduler' ); } public function doAction( $isExitCode, $oTask ) { static $_iPageLoadID; $_iPageLoadID = $_iPageLoadID ? $_iPageLoadID : uniqid(); $_oCallerInfo = debug_backtrace(); $_sCallerFunction = isset( $_oCallerInfo[ 1 ]['function'] ) ? $_oCallerInfo[ 1 ]['function'] : ''; $_sCallerClasss = isset( $_oCallerInfo[ 1 ]['class'] ) ? $_oCallerInfo[ 1 ]['class'] : ''; file_put_contents( WP_CONTENT_DIR . DIRECTORY_SEPARATOR . get_class() . '_' . date( "Ymd" ) . '.log', date( "Y/m/d H:i:s", current_time( 'timestamp' ) ) . ' ' . "{$_iPageLoadID} {$_sCallerClasss}::{$_sCallerFunction} " . self::getCurrentURL() . PHP_EOL . print_r( $oTask->getMeta(), true ) . PHP_EOL . PHP_EOL, FILE_APPEND ); return 1; } static public function getCurrentURL() { $sSSL = ( !empty( $_SERVER['HTTPS'] ) && $_SERVER['HTTPS'] == 'on' ) ? true:false; $sServerProtocol = strtolower( $_SERVER['SERVER_PROTOCOL'] ); $sProtocol = substr( $sServerProtocol, 0, strpos( $sServerProtocol, '/' ) ) . ( ( $sSSL ) ? 's' : '' ); $sPort = $_SERVER['SERVER_PORT']; $sPort = ( ( !$sSSL && $sPort=='80' ) || ( $sSSL && $sPort=='443' ) ) ? '' : ':' . $sPort; $sHost = isset( $_SERVER['HTTP_X_FORWARDED_HOST'] ) ? $_SERVER['HTTP_X_FORWARDED_HOST'] : isset( $_SERVER['HTTP_HOST'] ) ? $_SERVER['HTTP_HOST'] : $_SERVER['SERVER_NAME']; return $sProtocol . '://' . $sHost . $sPort . $_SERVER['REQUEST_URI']; } }class TaskScheduler_Action_Email extends TaskScheduler_Action_Base { public function construct() { new TaskScheduler_Action_Email_Thread( 'task_scheduler_action_send_indiviual_email' ); } public function getLabel( $sLabel ) { return __( 'Send Emails', 'task-scheduler' ); } public function getDescription( $sDescription ) { return __( 'Sends an email to specified email addresses.', 'task-scheduler' ); } public function doAction( $isExitCode, $oTask ) { $_aTaskMeta = $oTask->getMeta(); if ( ! isset( $_aTaskMeta[ $this->sSlug ], $_aTaskMeta[ $this->sSlug ]['email_addresses'], $_aTaskMeta[ $this->sSlug ]['email_title'], $_aTaskMeta[ $this->sSlug ]['email_message'] ) || ! is_array( $_aTaskMeta[ $this->sSlug ]['email_addresses'] ) ) { return 0; } $_iThreads = 0; $_aEmailOptions = $_aTaskMeta[ $this->sSlug ]; foreach( $_aEmailOptions['email_addresses'] as $_iIndex => $_sEmailAddress ) { $_aTaskOptions = array( 'routine_action' => 'task_scheduler_action_send_indiviual_email', 'post_title' => sprintf( __( 'Thread %1$s of %2$s', 'task-scheduler' ), $_iIndex + 1, $oTask->post_title ), 'parent_routine_log_id' => $oTask->log_id, '_next_run_time' => microtime( true ) + $_iIndex, 'email_address' => $_sEmailAddress, 'email_title' => $_aEmailOptions['email_title'], 'email_message' => $_aEmailOptions['email_message'], ); $_iThreadTaskID = TaskScheduler_ThreadUtility::add( $oTask->ID, $_aTaskOptions ); $_iThreads = $_iThreadTaskID ? ++$_iThreads : $_iThreads; } if ( $_iThreads ) { do_action( 'task_scheduler_action_check_shceduled_actions' ); } return null; } }class TaskScheduler_Action_Email_Thread extends TaskScheduler_Action_Base { public function construct() { add_filter( 'task_scheduler_filter_task_email_subject', array( $this, '_replyToFormatEmailText' ), 10, 2 ); add_filter( 'task_scheduler_filter_task_email_body', array( $this, '_replyToFormatEmailText' ), 10, 2 ); } public function getLabel( $sLabel ) { return __( 'Send Each Email', 'task-scheduler' ); } public function doAction( $isExitCode, $oThread ) { $_aThreadMeta = $oThread->getMeta(); if ( ! isset( $_aThreadMeta[ 'email_address' ], $_aThreadMeta['email_title'], $_aThreadMeta['email_message'] ) ) { return 0; } return wp_mail( $_aThreadMeta[ 'email_address' ], apply_filters( 'task_scheduler_filter_task_email_subject', $_aThreadMeta['email_title'], $oThread ), apply_filters( 'task_scheduler_filter_task_email_body', $_aThreadMeta['email_message'], $oThread ) ); } public function _replyToFormatEmailText( $sText, $oThread ) { $_oOwner = $oThread->getOwner(); $_sOccurrence = $_oOwner->occurrence ? $_oOwner->occurrence : $oThread->occurrence; $_sAction = $_oOwner->routine_action ? $_oOwner->routine_action : $oThread->routine_action; $_aFind = array( 0 => '%task_name%', 1 => '%task_description%', 2 => '%occurrence%', 3 => '%action%', 4 => '%site_url%', 5 => '%site_name%', 6 => '%admin_email%', ); $_aChange = array( 0 => $_oOwner->post_title ? $_oOwner->post_title : $oThread->post_title, 1 => $_oOwner->post_excerpt ? $_oOwner->post_excerpt : $oThread->post_excerpt, 2 => trim( apply_filters( "task_scheduler_filter_label_occurrence_" . $_sOccurrence, $_sOccurrence ) ), 3 => trim( apply_filters( "task_scheduler_filter_label_action_" . $_sAction, $_sAction ) ), 4 => get_option( 'siteurl' ), 5 => get_option( 'blogname' ), 6 => get_option( 'admin_email' ), ); return str_replace( $_aFind , $_aChange, $sText ); } }class TaskScheduler_Action_PostDeleter extends TaskScheduler_Action_Base { public function construct() { new TaskScheduler_Action_PostDeleter_Thread( 'task_scheduler_action_post_deleter_thread' ); } public function getLabel( $sLabel ) { return __( 'Delete Posts', 'task-scheduler' ); } public function getDescription( $sDescription ) { return __( 'Deletes posts by post type, taxonomy, and taxonomy terms.', 'task-scheduler' ); } public function doAction( $sExitCode, $oRoutine ) { $_aRoutineMeta = $oRoutine->getMeta(); $_aRoutineArguments = isset( $_aRoutineMeta[ $this->sSlug ] ) ? $_aRoutineMeta[ $this->sSlug ] : array(); if ( ! isset( $_aRoutineMeta[ $this->sSlug ], $_aRoutineArguments['post_type_of_deleting_posts'], $_aRoutineArguments['post_statuses_of_deleting_posts'], $_aRoutineArguments['taxonomy_of_deleting_posts'] ) ) { return 0; } if ( $oRoutine->hasThreads() ) { $oRoutine->log( 'There is a thread already.' ); return 0; } $_iThreadTaskID = TaskScheduler_ThreadUtility::create( $oRoutine->ID, array( '_next_run_time' => microtime( true ), 'routine_action' => 'task_scheduler_action_post_deleter_thread', 'post_title' => sprintf( __( 'Thread %1$s of %2$s', 'task-scheduler' ), 1, $oRoutine->post_title ), 'post_excerpt' => sprintf( __( 'Deletes posts defined in %1$s', 'task-scheduler' ), $oRoutine->post_title ), 'parent_routine_log_id' => $oRoutine->log_id, 'post_type_of_deleting_posts' => $_aRoutineArguments['post_type_of_deleting_posts'], 'post_statuses_of_deleting_posts' => $_aRoutineArguments['post_statuses_of_deleting_posts'], 'taxonomy_of_deleting_posts' => $_aRoutineArguments['taxonomy_of_deleting_posts'], 'term_ids_of_deleting_posts' => isset( $_aRoutineArguments['term_ids_of_deleting_posts'] ) ? $_aRoutineArguments['term_ids_of_deleting_posts'] : null, 'number_of_posts_to_delete_per_routine' => $_aRoutineArguments['number_of_posts_to_delete_per_routine'] ? $_aRoutineArguments['number_of_posts_to_delete_per_routine'] : null, ) ); if ( $_iThreadTaskID ) { do_action( 'task_scheduler_action_check_shceduled_actions' ); } return null; } }class TaskScheduler_Action_PostDeleter_Thread extends TaskScheduler_Action_Base { public function construct() {} public function getLabel( $sLabel ) { return __( 'Deleting Posts', 'task-scheduler' ); } public function doAction( $isExitCode, $oThread ) { $_oTask = $oThread->getOwner(); if ( ! is_object( $_oTask ) ) { return 1; } $_aThreadMeta = $oThread->getMeta(); if ( ! isset( $_aThreadMeta[ 'post_type_of_deleting_posts' ], $_aThreadMeta[ 'post_statuses_of_deleting_posts' ], $_aThreadMeta[ 'taxonomy_of_deleting_posts' ], $_aThreadMeta[ 'term_ids_of_deleting_posts' ] ) ) { $_oTask->log( 'Required keys are missing.', $oThread->parent_routine_log_id ); return 1; } $_iNumberOfPostsToDelete = isset( $_aThreadMeta[ 'number_of_posts_to_delete_per_routine' ] ) ? $_aThreadMeta[ 'number_of_posts_to_delete_per_routine' ] : 20; $_aPostIDsToDelete = $this->_getPostIDs( $_aThreadMeta[ 'post_type_of_deleting_posts' ], $_aThreadMeta[ 'post_statuses_of_deleting_posts' ], $_aThreadMeta[ 'taxonomy_of_deleting_posts' ], $_aThreadMeta[ 'term_ids_of_deleting_posts' ], $_iNumberOfPostsToDelete + 1 ); if ( ! count( $_aPostIDsToDelete ) ) { $_oTask->log( 'No more post IDs found to to delete.', $oThread->parent_routine_log_id ); return 1; } $_aChunks_PostIDs = array_chunk( $_aPostIDsToDelete, $_iNumberOfPostsToDelete ); $_bHasRemain = isset( $_aChunks_PostIDs[ 1 ] ) && 0 < count( $_aChunks_PostIDs[ 1 ] ); $_aDeleted = array(); foreach( $_aChunks_PostIDs[ 0 ] as $_iPostID ) { if( wp_delete_post( $_iPostID, true ) ) { $_aDeleted[] = $_iPostID; } } if ( ! empty( $_aDeleted ) ) { $_oTask->log( 'Deleted the posts: ' . implode( ', ', $_aDeleted ), $oThread->parent_routine_log_id ); } if ( ! $_bHasRemain ) { $_oTask->log( 'Deleted all the posts.', $oThread->parent_routine_log_id ); return 1; } do_action( 'task_scheduler_action_check_shceduled_actions' ); $oThread->setMeta( '_next_run_time', microtime( true ) ); return 'NOT_DELETE'; } private function _getPostIDs( $asPostType, $asPostStatus, $sTaxonomy=-1, $aTerms=array(), $iLimit=200 ) { $_aQueryArgs = array( 'post_type' => $asPostType, 'post_status' => $asPostStatus, 'posts_per_page' => $iLimit, 'orderby' => 'date ID', 'order' => 'ASC', 'fields' => 'ids', ); if ( $sTaxonomy && '-1' !== ( string ) $sTaxonomy && ! empty( $aTerms ) ) { $_aQueryArgs['tax_query'] = array( 'relation' => 'AND', array( 'taxonomy' => $sTaxonomy, 'field' => 'term_id', 'terms' => $aTerms, ), ); } $_oResults = new WP_Query( $_aQueryArgs ); return $_oResults->posts; } }class TaskScheduler_Action_HungRoutineHandler_Thread extends TaskScheduler_Action_Base { public function construct() { add_action( 'task_scheduler_action_add_hung_routine_handler_thread', array( $this, '_replyToAddHungRoutineHandlerThread' ) ); } public function getLabel( $sLabel ) { return __( 'Handle Hung Task', 'task-scheduler' ); } public function _replyToAddHungRoutineHandlerThread( $oTask ) { if ( ! $oTask->_max_execution_time ) { return; } $_aThreadOptions = array( '_next_run_time' => 10 + microtime( true ) + ( int ) $oTask->_max_execution_time, 'routine_action' => $this->sSlug, 'post_title' => sprintf( __( 'Hung Routine Handler of "%1$s"', 'task-scheduler' ), $oTask->post_title ), 'post_excerpt' => sprintf( __( 'Do some clearance if the task "%1$s" is hung.', 'task-scheduler' ), $oTask->post_title ), '_max_root_log_count' => 0, 'log_id' => 0, '_owner_spawned_time' => $oTask->_spawned_time, ); $_iThreadID = TaskScheduler_ThreadUtility::create( $oTask->ID, $_aThreadOptions, array( 'system', 'internal' ) ); } public function doAction( $isExitCode, $oThread ) { $_oTask = TaskScheduler_Routine::getInstance( $oThread->owner_routine_id ); if ( ! in_array( $_oTask->_routine_status, array( 'processing', 'awaiting' ) ) ) { return 1; } if ( $oThread->_owner_spawned_time != $_oTask->_spawned_time ) { return 1; } if ( $_oTask->hasThreads() && 'processing' == $_oTask->_routine_status ) { $oThread->setMeta( '_next_run_time', 10 + microtime( true ) + ( int ) $_oTask->_max_execution_time ); return 'NOT_DELETE'; } $_oTask->setMeta( '_routine_status', 'inactive' ); $_oTask->setMeta( '_count_hung', ( int ) $_oTask->getMeta( '_count_hung' ) + 1 ); return 1; } }class TaskScheduler_Action_RoutineLogDeleter extends TaskScheduler_Action_Base { public function construct() { new TaskScheduler_Action_RoutineLogDeleter_Thread( 'task_scheduler_action_delete_each_task_log' ); } public function getLabel( $sLabel ) { return __( 'Delete Task Log', 'task-scheduler' ); } public function doAction( $sExitCode, $oTask ) { $_iTargetTaskID = $oTask->_target_routine_id; $_iRemain = $oTask->_max_root_log_count_of_the_target; $_iRootLogs = TaskScheduler_LogUtility::getRootLogCount( $_iTargetTaskID ); if ( $_iRootLogs <= $_iRemain ) { return 'DELETE'; } $_aThreadOptions = array( '_next_run_time' => microtime( true ), 'routine_action' => 'task_scheduler_action_delete_each_task_log', 'post_title' => sprintf( __( 'Thread %1$s of %2$s', 'task-scheduler' ), 1, $oTask->post_title ), '_max_root_log_count' => 0, 'log_id' => 0, '_target_routine_id' => $_iTargetTaskID, '_max_root_log_count_of_the_target' => $_iRemain, ); TaskScheduler_ThreadUtility::add( $oTask->ID, $_aThreadOptions ); do_action( 'task_scheduler_action_check_shceduled_actions' ); return 1; } }class TaskScheduler_Action_RoutineLogDeleter_Thread extends TaskScheduler_Action_Base { public function construct() { } public function getLabel( $sLabel ) { return __( 'Thread of Deleting Task Log ', 'task-scheduler' ); } public function doAction( $isExitCode, $oThread ) { $_aThreadMeta = $oThread->getMeta(); if ( ! $oThread->_target_routine_id ) { return 0; } if ( ! $oThread->_max_root_log_count_of_the_target ) { foreach( TaskScheduler_LogUtility::getLogIDs( $oThread->_target_routine_id ) as $_iLogID ) { if ( TaskScheduler_LogUtility::doesPostExist( $_iLogID ) ) { wp_delete_post( $_iLogID, true ); } } return 1; } $_aRootLogIDs = TaskScheduler_LogUtility::getRootLogIDs( $oThread->_target_routine_id ); $_iNumberToDelete = count( $_aRootLogIDs ) - ( int ) $oThread->_max_root_log_count_of_the_target; if ( $_iNumberToDelete < 1 ) { return 1; } foreach( $_aRootLogIDs as $_iIndex => $_iRootLogID ) { TaskScheduler_LogUtility::deleteChildLogs( $_iRootLogID, $oThread->_target_routine_id ); if ( TaskScheduler_LogUtility::doesPostExist( $_iRootLogID ) ) { $_vDelete = wp_delete_post( $_iRootLogID, true ); } if ( $_iIndex + 1 >= $_iNumberToDelete ) { break; } } return 1; } }class TaskScheduler_Occurrence_Constant extends TaskScheduler_Occurrence_Base { public function construct() {} public function getLabel( $sSlug ) { return __( 'Constant', 'task-scheduler' ); } public function getDescription( $sDescription ) { return __( 'Triggers actions constantly, used by system internal routines.', 'task-scheduler' ); } public function doAfterAction( $oTask, $isExitCode ) {} public function getNextRunTime( $iTimestamp, $oTask ) { return microtime( true ) + 3; } }class TaskScheduler_Occurrence_ExitCode extends TaskScheduler_Occurrence_Base { public function construct() {} public function getLabel( $sSlug ) { return __( 'Exit Code', 'task-scheduler' ); } public function getDescription( $sDescription ) { return __( 'Triggers actions when the specified exit code is received.', 'task-scheduler' ); } public function doAfterAction( $oTask, $sExitCode ) {} public function getNextRunTime( $iTimeStamp, $oTask ) { return ''; } }class TaskScheduler_Occurrence_FixedInterval extends TaskScheduler_Occurrence_Base { public function construct() {} public function getLabel( $sSlug ) { return __( 'Fixed Interval', 'task-scheduler' ); } public function getDescription( $sDescription ) { return __( 'Triggers actions at the set interval.', 'task-scheduler' ); } public function doAfterAction( $oTask, $sExitCode ) {} public function getNextRunTime( $iTimestamp, $oTask ) { $_aOptions = $oTask->getMeta( $this->sSlug ); if ( ! isset( $_aOptions['interval'][ 0 ], $_aOptions['interval'][ 1 ] ) ) { return $iTimestamp; } $_nLastRunTime = $oTask->_last_run_time ? $oTask->_last_run_time : microtime( true ); $_iInterval = $this->_getIntervalInSeconds( $_aOptions['interval'][ 0 ], $_aOptions['interval'][ 1 ] ); return $_nLastRunTime + $_iInterval; } private function _getIntervalInSeconds( $iSeconds, $sUnit ) { switch( $sUnit ) { default: case 'second': return $iSeconds; case 'minute': return $iSeconds * 60; case 'hour': return $iSeconds * 60*60; case 'day': return $iSeconds * 60*60*24; } } }class TaskScheduler_Occurrence_SpecificTime extends TaskScheduler_Occurrence_Base { public function construct() {} public function getLabel( $sSlug ) { return __( 'Specific Time', 'task-scheduler' ); } public function getDescription( $sDescription ) { return __( 'Triggers actions at the specified time.', 'task-scheduler' ); } public function doAfterAction( $oTask, $sExitCode ) {} public function getNextRunTime( $iTimestamp, $oTask ) { $_aOpitons = $oTask->getMeta( $this->sSlug ); if ( ! isset( $_aOpitons['when'] ) || ! is_array( $_aOpitons['when'] ) ) { return $iTimestamp; } $_aSetTimes = $this->_convertDateToTimeStamp( $_aOpitons['when'] ); $_nLastRunTime = $oTask->_last_run_time ? $oTask->_last_run_time : 0; foreach( $_aSetTimes as $_nSetTime ) { if ( $_nSetTime < $_nLastRunTime ) { continue; } return $_nSetTime; } return $iTimestamp; } private function _convertDateToTimeStamp( array $aDateTimes ) { $_aTimeStamps = array(); foreach( $aDateTimes as $_sDateTime ) { $_aTimeStamps[] = strtotime( $_sDateTime ) - ( get_option( 'gmt_offset' ) * 60*60 ); } asort( $_aTimeStamps ); return $_aTimeStamps; } }class TaskScheduler_Occurrence_Volatile extends TaskScheduler_Occurrence_Base { public function construct() {} public function getLabel( $sSlug ) { return __( 'Volatile', 'task-scheduler' ); } public function getDescription( $sDescription ) { return __( 'Triggers actions only once, used mostly by threads.', 'task-scheduler' ); } public function doAfterAction( $oRoutine, $sExitCode ) { if ( 'NOT_DELETE' === $sExitCode ) { return; } $vRet = $oRoutine->delete(); } }abstract class TaskScheduler_Wizard_Base { protected $_sTransientKey; protected $_sMainAdminPageClassName = 'TaskScheduler_AdminPage_Wizard'; protected $_sMainAdminPageSlug = ''; protected $_sEditAdminPageClassName = 'TaskScheduler_AdminPage_EditModule'; protected $_sEditAdminPageSlug = ''; protected $_sParentTabSlug = 'wizard'; public $sSlug; public $sMainWizardSlug; protected $_sSectionID; public $sNextTabSlug; protected $_sModuleType = 'base'; public $bAddToLabelList = true; protected $_bIsAddNew; public function __construct( $sSlug, $sMainWizardSlug='' ) { $this->_setProperties( $sSlug, $sMainWizardSlug ); $this->_setCallbacks(); $this->construct(); } protected function _setProperties( $sSlug, $sMainWizardSlug ) { $this->sSlug = $sSlug ? $sSlug : $this->sSlug; $this->sMainWizardSlug = $sMainWizardSlug ? $sMainWizardSlug : $sSlug; $this->_sTransientKey = isset( $_GET['transient_key'] ) ? $_GET['transient_key'] : ''; $this->_sSectionID = $this->sSlug; $this->_sMainAdminPageSlug = TaskScheduler_Registry::AdminPage_AddNew; $this->_sEditAdminPageSlug = TaskScheduler_Registry::AdminPage_EditModule; $this->_bIsAddNew = isset( $_GET['page'] ) && $this->_sMainAdminPageSlug === $_GET['page']; $this->sNextTabSlug = $this->_bIsAddNew ? $this->sNextTabSlug : 'update_module'; } protected function _setCallbacks() { add_filter( "tabs_{$this->_sMainAdminPageClassName}_{$this->_sMainAdminPageSlug}", array( $this, '_replyToAddInPageTab' ) ); add_filter( "sections_{$this->_sMainAdminPageClassName}", array( $this, '_replyToAddFormSection' ) ); add_filter( "fields_{$this->_sMainAdminPageClassName}", array( $this, '_replyToAddFormFields' ), 1, 1 ); add_filter( "field_definition_{$this->_sMainAdminPageClassName}", array( $this, '_replyToRedefineFields' ), 10, 1 ); add_filter( "validation_{$this->_sMainAdminPageClassName}_{$this->_sSectionID}", array( $this, 'validateSettings' ), 10, 3 ); add_filter( "validation_{$this->_sMainAdminPageSlug}_{$this->sSlug}", array( $this, '_replytToValidateTabSettings' ), 10, 3 ); add_filter( "validation_saved_options_{$this->_sMainAdminPageSlug}_{$this->sSlug}", array( $this, '_replyToModifySavedTabOptions' ), 10, 2 ); add_filter( "tabs_{$this->_sEditAdminPageClassName}_{$this->_sEditAdminPageSlug}", array( $this, '_replyToAddInPageTab' ) ); add_filter( "sections_{$this->_sEditAdminPageClassName}", array( $this, '_replyToAddFormSection' ) ); add_filter( "fields_{$this->_sEditAdminPageClassName}", array( $this, '_replyToAddFormFields' ), 1, 1 ); add_filter( "field_definition_{$this->_sEditAdminPageClassName}", array( $this, '_replyToRedefineFields' ), 10, 1 ); add_filter( "validation_{$this->_sEditAdminPageClassName}_{$this->_sSectionID}", array( $this, 'validateSettings' ), 10, 3 ); add_filter( "validation_{$this->_sEditAdminPageSlug}_{$this->sSlug}", array( $this, '_replytToValidateTabSettings' ), 10, 3 ); add_filter( "validation_saved_options_{$this->_sEditAdminPageSlug}_{$this->sSlug}", array( $this, '_replyToModifySavedTabOptions' ), 10, 2 ); add_filter( "task_scheduler_admin_filter_field_labels_wizard_" . $this->_sModuleType, array( $this, '_replyToAddActionLabel' ) ); add_filter( "task_scheduler_admin_filter_wizard_" . $this->_sModuleType . "_redirect_url_" . $this->sSlug, array( $this, "_replyToSetRedirectURL" ), 10, 2 ); add_filter( "task_scheduler_filter_fields_{$this->sSlug}", array( $this, '_replyToAddFormFields' ) ); } public function _replyToSetRedirectURL( $sRedirectURL, $aWizardOptions ) { $_sReturn = add_query_arg( array( 'tab' => $this->sSlug, ), $sRedirectURL ); return $_sReturn; } public function _replyToAddFormSection( $aSections ) { $aSections[ $this->_sSectionID ] = array( 'page_slug' => "sections_{$this->_sMainAdminPageClassName}" === current_filter() ? $this->_sMainAdminPageSlug : $this->_sEditAdminPageSlug, 'tab_slug' => $this->sSlug, 'section_id' => $this->_sSectionID, 'title' => $this->getLabel(), ); return $aSections; } public function _replyToAddFormFields( $aAllFields ) { $_aFields = array(); foreach( ( array ) $this->getFields() as $_aField ) { if ( ! isset( $_aField['field_id'] ) ) { continue; } $_aField['section_id'] = $this->_sSectionID; $_aFields[ $_aField['field_id'] ] = $_aField; } $_aSubmitButtons = $this->_getSubmitButtonsField(); if ( ! empty( $_aSubmitButtons ) ) { $_aFields[ $_aSubmitButtons['field_id'] ] = $_aSubmitButtons; } $aAllFields[ $this->_sSectionID ] = $_aFields; return $aAllFields; } protected function _getSubmitButtonsField() { $_sButtonLabel = $this->_bIsAddNew ? ( 'wizard_create_task' === $this->sNextTabSlug ? __( 'Create', 'task-scheduler' ) : __( 'Next', 'task-scheduler' ) ) : ( 'update_module' === $this->sNextTabSlug ? __( 'Update', 'task-scheduler' ) : __( 'Next', 'task-scheduler' ) ); $_aSubmitField = array( 'section_id' => $this->_sSectionID, 'field_id' => 'submit', 'type' => 'submit', 'label' => $_sButtonLabel, 'label_min_width' => 0, 'attributes' => array( 'field' => array( 'style' => 'float:right; clear:none; display: inline;', ), ), 'redirect_url' => add_query_arg( array( 'tab' => $this->sNextTabSlug, 'settings-notice' => 0, 'transient_key' => $this->_sTransientKey, ) ), array( 'value' => __( 'Back', 'task-scheduler' ), 'attributes' => array( 'class' => 'button secondary ', ), ), ); return $_aSubmitField; } public function _replyToRedefineFields( $aAllFields ) { if ( ! isset( $aAllFields[ $this->_sSectionID ] ) || ! $this->_sTransientKey ) { return $aAllFields; } if ( ! isset( $aAllFields[ $this->_sSectionID ][ 'submit' ] ) ) { return $aAllFields; } $_aWizardOptions = apply_filters( 'task_scheduler_admin_filter_get_wizard_options', array() ); foreach( $aAllFields[ $this->_sSectionID ] as $_sFieldID => &$_aField ) { if ( ! isset( $_aWizardOptions[ $this->_sSectionID ][ $_sFieldID ] ) ) { continue; } if ( ( $_aField['repeatable'] || isset( $_aField[ 0 ] ) ) && is_array( $_aWizardOptions[ $this->_sSectionID ][ $_sFieldID ] ) ) { $_aThisFieldValues = array_values( $_aWizardOptions[ $this->_sSectionID ][ $_sFieldID ] ); $_aField['value'] = array_shift( $_aThisFieldValues ); $_iIndex = 0; foreach( $_aThisFieldValues as $_vValue ) { $_aField[ $_iIndex ]['value'] = $_vValue; $_iIndex++; } continue; } $_aField['value'] = $_aWizardOptions[ $this->_sSectionID ][ $_sFieldID ]; } $_sCurrentURLKey = remove_query_arg( array( 'transient_key', 'settings-notice', 'settings-updated' ) ); if ( isset( $_aWizardOptions['previous_urls'][ $_sCurrentURLKey ] ) ) { $aAllFields[ $this->_sSectionID ][ 'submit' ][ 0 ]['href'] = $_aWizardOptions['previous_urls'][ $_sCurrentURLKey ]; } return $aAllFields; } public function _replyToAddInPageTab( $aTabs ) { $aTabs[ $this->sSlug ] = array( 'page_slug' => "tabs_{$this->_sMainAdminPageClassName}_{$this->_sMainAdminPageSlug}" === current_filter() ? $this->_sMainAdminPageSlug : $this->_sEditAdminPageSlug, 'tab_slug' => $this->sSlug, 'title' => $this->getLabel(), 'parent_tab_slug' => $this->_sParentTabSlug, 'show_in_page_tab' => true, ); return $aTabs; } public function _replytToValidateTabSettings( $aInput, $aOldInput, $oAdminPage ) { $_aWizardOptions = array( 'previous_urls' => apply_filters( 'task_scheduler_admin_filter_get_wizard_options', array(), 'previous_urls' ), ); if ( ! $oAdminPage->hasSettingNotice( 'error' ) ) { $_sNextURLKey = remove_query_arg( array( 'transient_key', 'settings-notice', 'settings-updated' ), add_query_arg( array( 'tab' => $this->sNextTabSlug ) ) ); $_aWizardOptions[ 'previous_urls' ][ $_sNextURLKey ] = add_query_arg( array() ); } $_aWizardOptions[ $this->_sSectionID ] = apply_filters( "task_scheduler_admin_filter_wizard_options_{$this->sMainWizardSlug}", $aInput[ $this->_sSectionID ] ) + ( isset( $aOldInput['_wizard_options'][ $this->sMainWizardSlug ] ) ? $aOldInput['_wizard_options'][ $this->sMainWizardSlug ] : array() ); unset( $_aWizardOptions[ $this->_sSectionID ]['submit'] ); $_aSlugs = apply_filters( "task_scheduler_admin_filter_wizard_slugs_{$this->sMainWizardSlug}", array() ); foreach( $_aSlugs as $_sSlug ) { $_aWizardOptions[ $_sSlug ] = $_aWizardOptions[ $this->_sSectionID ]; } $aInput['_wizard_options'] = $_aWizardOptions; return $aInput; } public function _replyToModifySavedTabOptions( $aSavedOptions, $oAdminPage ) { unset( $aSavedOptions[ '_wizard_options' ][ $this->sSlug ] ); return $aSavedOptions; } public function _replyToAddActionLabel( $aLabels ) { if ( ! $this->bAddToLabelList ) { return $aLabels; } $aLabels[ $this->sSlug ] = $this->getLabel(); return $aLabels; } public function getLabel() { return apply_filters( "task_scheduler_filter_label_" . $this->_sModuleType . "_" . $this->sMainWizardSlug, $this->sMainWizardSlug ); } public function getFields() { return array(); } public function validateSettings( $aInput, $aOldInput, $oAdminPage ) { return $aInput; } public function construct() {} }abstract class TaskScheduler_Wizard_Action_Base extends TaskScheduler_Wizard_Base { public $sNextTabSlug = 'wizard_create_task'; protected $_sModuleType = 'action'; }abstract class TaskScheduler_Wizard_Occurrence_Base extends TaskScheduler_Wizard_Base { public $sNextTabSlug = 'wizard_select_action'; protected $_sModuleType = 'occurrence'; }final class TaskScheduler_Action_Debug_Wizard extends TaskScheduler_Wizard_Action_Base { public function _replyToSetRedirectURL( $sRedirectURL, $aWizardOptions ) { return add_query_arg( array( 'tab' => $this->sNextTabSlug, 'transient_key' => $this->_sTransientKey, ) ); } }final class TaskScheduler_Action_Email_Wizard extends TaskScheduler_Wizard_Action_Base { public function getFields() { return array( array( 'field_id' => 'email_addresses', 'title' => __( 'Email Addresses', 'task-scheduler' ), 'type' => 'text', 'repeatable' => true, ), array( 'field_id' => 'email_title', 'title' => __( 'Email Title', 'task-scheduler' ), 'type' => 'text', 'default' => __( 'Automated Email Notice of %task_name% - %site_name%', 'task-scheduler' ), 'attributes' => array( 'size' => 60, ), ), array( 'field_id' => 'email_message', 'title' => __( 'Email Message', 'task-scheduler' ), 'type' => 'textarea', 'rich' => true, 'default' => sprintf( __( 'This is an automated email message from %1$s (%2$s), sent by the task, %3$s, with the %4$s occurrence type.', 'task-scheduler' ), '%site_name%', '%site_url%', '%task_name%', '%occurrence%' ) . PHP_EOL . PHP_EOL . '%task_description%', 'after_fields' => '<div class="action-email-field-description"><h5>' . __( 'Available variables', 'task-scheduler' ) . '</h5>' . '<ul>' . '<li><code>%task_name%</code> - ' . __( 'the task name', 'task-scheduler' ) . '</li>' . '<li><code>%task_description%</code> - ' . __( 'the task description', 'task-scheduler' ) . '</li>' . '<li><code>%occurrence%</code> - ' . __( 'the occurrence type', 'task-scheduler' ) . '</li>' . '<li><code>%action%</code> - ' . __( 'the action name', 'task-scheduler' ) . '</li>' . '<li><code>%site_url%</code> - ' . __( 'the site url', 'task-scheduler' ) . '</li>' . '<li><code>%site_name%</code> - ' . __( 'the site name', 'task-scheduler' ) . '</li>' . '<li><code>%admin_email%</code> - ' . __( 'the admin email address', 'task-scheduler' ) . '</li>' . '</ul>' . '</div>', ), ); } public function validateSettings( $aInput, $aOldInput, $oAdminPage ) { $_bIsValid = true; $_aErrors = array(); $aInput['email_addresses'] = array_filter( $aInput['email_addresses'] ); $aInput['email_addresses'] = array_unique( $aInput['email_addresses'] ); if ( empty( $aInput['email_addresses'] ) ) { $_aErrors[ $this->_sSectionID ][ 'email_addresses' ] = __( 'At least one item needs to be set.', 'task-scheduler' ); $_bIsValid = false; } foreach ( $aInput['email_addresses'] as $_iIndex => $_sEmail ) { if ( ! filter_var( $_sEmail, FILTER_VALIDATE_EMAIL ) ) { unset( $aInput['email_addresses'][ $_iIndex ] ); $_bIsValid = false; $_aErrors[ $this->_sSectionID ][ 'email_addresses' ] = __( 'There was an invalid e-mail address.', 'task-scheduler' ); } } $aInput['email_addresses'] = array_values( $aInput['email_addresses'] ); if ( ! $_bIsValid ) { $oAdminPage->setFieldErrors( $_aErrors ); $oAdminPage->setSettingNotice( __( 'Please try again.', 'task-scheduler' ) ); } return $aInput; } }final class TaskScheduler_Action_PostDeleter_Wizard extends TaskScheduler_Wizard_Action_Base { public function construct() {} public function getFields() { return array( array( 'field_id' => 'post_type_of_deleting_posts', 'title' => __( 'Post Type', 'task-scheduler' ), 'type' => 'select', 'label' => TaskScheduler_WPUtility::getRegisteredPostTypeLabels(), ), array( 'field_id' => 'post_statuses_of_deleting_posts', 'title' => __( 'Post Statuses', 'task-scheduler' ), 'type' => 'checkbox', 'label' => TaskScheduler_WPUtility::getRegisteredPostStatusLabels(), 'default' => array( 'trash' => 1 ), ), ); } public function validateSettings( $aInput, $aOldInput, $oAdminPage ) { $_bIsValid = true; $_aErrors = array(); $_aCheckedPostStatuses = isset( $aInput['post_statuses_of_deleting_posts'] ) ? $aInput['post_statuses_of_deleting_posts'] : array(); $_aCheckedPostStatuses = array_filter( $_aCheckedPostStatuses ); if ( empty( $_aCheckedPostStatuses ) ) { $_aErrors[ $this->_sSectionID ][ 'post_statuses_of_deleting_posts' ] = __( 'At least one item needs to be checked.', 'task-scheduler' ); $_bIsValid = false; } if ( ! $_bIsValid ) { $oAdminPage->setFieldErrors( $_aErrors ); $oAdminPage->setSettingNotice( __( 'Please try again.', 'task-scheduler' ) ); } return $aInput; } }final class TaskScheduler_Action_PostDeleter_Wizard_2 extends TaskScheduler_Wizard_Action_Base { public function getFields() { $_aWizardOptions = apply_filters( 'task_scheduler_admin_filter_get_wizard_options', array(), $this->sSlug ); return array( array( 'field_id' => 'post_type_label_of_deleting_posts', 'title' => __( 'Post Type', 'task-scheduler' ), 'type' => 'text', 'attributes' => array( 'readonly' => 'ReadOnly', 'name' => '', ), 'value' => TaskScheduler_WPUtility::getPostTypeLabel( isset( $_aWizardOptions['post_type_of_deleting_posts'] ) ? $_aWizardOptions['post_type_of_deleting_posts'] : null ), ), array( 'field_id' => 'post_statuses_of_deleting_posts', 'title' => __( 'Post Statuses', 'task-scheduler' ), 'type' => 'checkbox', 'label' => TaskScheduler_WPUtility::getRegisteredPostStatusLabels(), 'attributes' => array( 'disabled' => 'Disabled', 'name' => '', ), ), array( 'field_id' => 'taxonomy_of_deleting_posts', 'title' => __( 'Taxonomy', 'task-scheduler' ), 'type' => 'select', 'label' => array( -1 => __( 'All Posts', 'task-scheduler' ), ) + TaskScheduler_WPUtility::getTaxonomiesByPostTypeSlug( isset( $_aWizardOptions['post_type_of_deleting_posts'] ) ? $_aWizardOptions['post_type_of_deleting_posts'] : null ), ), ); } public function validateSettings( $aInput, $aOldInput, $oAdminPage ) { unset( $aInput['post_statuses_of_deleting_posts'], $aInput['post_type_label_of_deleting_posts'] ); return $aInput; } }final class TaskScheduler_Action_PostDeleter_Wizard_3 extends TaskScheduler_Wizard_Action_Base { public function getFields() { $_aWizardOptions = apply_filters( 'task_scheduler_admin_filter_get_wizard_options', array(), $this->sSlug ); $_bIsTaxonomySet = isset( $_aWizardOptions['taxonomy_of_deleting_posts'] ) && -1 !== $_aWizardOptions['taxonomy_of_deleting_posts'] && '-1' !== $_aWizardOptions['taxonomy_of_deleting_posts']; return array( array( 'field_id' => 'post_type_label_of_deleting_posts', 'title' => __( 'Post Type', 'task-scheduler' ), 'type' => 'text', 'attributes' => array( 'readonly' => 'ReadOnly', 'name' => '', ), 'value' => TaskScheduler_WPUtility::getPostTypeLabel( isset( $_aWizardOptions['post_type_of_deleting_posts'] ) ? $_aWizardOptions['post_type_of_deleting_posts'] : null ), ), array( 'field_id' => 'post_statuses_of_deleting_posts', 'title' => __( 'Post Statuses', 'task-scheduler' ), 'type' => 'checkbox', 'label' => TaskScheduler_WPUtility::getRegisteredPostStatusLabels(), 'attributes' => array( 'disabled' => 'Disabled', 'name' => '', ), ), array( 'field_id' => 'taxonomy_label_of_deleting_posts', 'title' => __( 'Taxonomy', 'task-scheduler' ), 'type' => 'text', 'attributes' => array( 'readonly' => 'ReadOnly', 'name' => '', ), 'value' => TaskScheduler_WPUtility::getTaxonomiyLabelBySlug( isset( $_aWizardOptions['taxonomy_of_deleting_posts'] ) ? $_aWizardOptions['taxonomy_of_deleting_posts'] : null ), 'if' => $_bIsTaxonomySet, ), array( 'field_id' => 'term_ids_of_deleting_posts', 'title' => __( 'Terms', 'task-scheduler' ), 'type' => 'taxonomy', 'taxonomy_slugs' => isset( $_aWizardOptions['taxonomy_of_deleting_posts'] ) ? $_aWizardOptions['taxonomy_of_deleting_posts'] : array(), 'if' => $_bIsTaxonomySet, ), array( 'field_id' => 'number_of_posts_to_delete_per_routine', 'title' => __( 'Number of Posts to Process per Routine', 'task-scheduler' ), 'type' => 'number', 'default' => 20, 'description' => __( 'This determines how many posts will be processed per a page load. Set a smaller number if the task gets hung.', 'task-scheduler' ), 'attributes' => array( 'min' => 1, 'step' => 1, ), ), ); } public function validateSettings( $aInput, $aOldInput, $oAdminPage ) { $_bIsValid = true; $_aErrors = array(); unset( $aInput['post_type_label_of_deleting_posts'], $aInput['post_statuses_of_deleting_posts'], $aInput['taxonomy_label_of_deleting_posts'] ); $_aCheckedPostStatuses = isset( $aInput['term_ids_of_deleting_posts'] ) ? $aInput['term_ids_of_deleting_posts'] : array(); $_aCheckedPostStatuses = array_filter( $_aCheckedPostStatuses ); if ( isset( $aInput['term_ids_of_deleting_posts'] ) && empty( $_aCheckedPostStatuses ) ) { $_aErrors[ $this->_sSectionID ][ 'term_ids_of_deleting_posts' ] = __( 'At least one item needs to be checked.', 'task-scheduler' ); $_bIsValid = false; } if ( ! $_bIsValid ) { $oAdminPage->setFieldErrors( $_aErrors ); $oAdminPage->setSettingNotice( __( 'Please try again.', 'task-scheduler' ) ); } $aInput['number_of_posts_to_delete_per_routine'] = $oAdminPage->oUtil->fixNumber( $aInput['number_of_posts_to_delete_per_routine'], 20, 1 ); return $aInput; } }final class TaskScheduler_Occurrence_ExitCode_Wizard extends TaskScheduler_Wizard_Occurrence_Base { private $_aSubmit = array(); public function construct() {} public function getFields() { return array( array( 'field_id' => 'exit_code', 'title' => __( 'Exit Code', 'task-scheduler' ), 'type' => 'text', ), array( 'field_id' => 'task_ids', 'title' => __( 'Tasks', 'task-scheduler' ), 'type' => 'autocomplete', 'description' => __( 'Leave this empty to apply to any tasks.', 'task-scheduler' ), 'settings' => add_query_arg( array( 'request' => 'autocomplete', 'post_type' => TaskScheduler_Registry::PostType_Task, 'post_status' => 'private', ) + $_GET, admin_url( TaskScheduler_AdminPageFramework_WPUtility::getPageNow() ) ), 'settings2' => array( 'preventDuplicates' => true, 'hintText' => __( 'Type a task name.', 'task-scheduler' ), 'searchDelay' => 5, ), ), ); } public function validateSettings( $aInput, $aOldInput, $oAdminPage ) { $_bIsValid = true; $_aErrors = array(); if ( ! isset( $aInput['exit_code'] ) || '' == $aInput['exit_code'] ) { $_aErrors[ $this->_sSectionID ][ 'exit_code' ] = __( 'An exit code need to be set.', 'task-scheduler' ); $_bIsValid = false; } if ( ! isset( $aInput['task_ids'] ) || '' == $aInput['task_ids'] ) { $_aErrors[ $this->_sSectionID ][ 'task_ids' ] = __( 'Task IDs are required.', 'task-scheduler' ); $_bIsValid = false; } if ( ! $_bIsValid ) { $oAdminPage->setFieldErrors( $_aErrors ); $oAdminPage->setSettingNotice( __( 'Please try again.', 'task-scheduler' ) ); return array(); } unset( $aInput['submit'] ); $this->_aSubmit = $aInput; add_filter( "task_scheduler_admin_filter_saving_wizard_options", array( $this, '_replyToSetTopLevelMetaData' ), 10, 3 ); return $aInput; } function _isActionSelected( $sActionSlug ) { return ( '-1' === $sActionSlug || -1 === $sActionSlug ) ? false : true; } public function _replyToSetTopLevelMetaData( $aWizardOptions ) { if ( empty( $this->_aSubmit ) ) { return $aWizardOptions; } $aWizardOptions[ '__on_exit_code' ] = $this->_aSubmit[ 'exit_code' ]; $aWizardOptions[ '__on_exit_code_task_ids' ] = $this->_getSetTaskIDs( $this->_aSubmit['task_ids'] ); if ( empty( $aWizardOptions[ '__on_exit_code_task_ids' ] ) ) { unset( $aWizardOptions[ '__on_exit_code_task_ids' ] ); } return $aWizardOptions; } private function _getSetTaskIDs( $sJSONTaskIDs ) { if ( ! $sJSONTaskIDs ) { return array(); } $_aJSONTaskIDs = json_decode( $sJSONTaskIDs, true ); $_aTaskIDs = array(); foreach( $_aJSONTaskIDs as $_aTaskID ) { if ( ! isset( $_aTaskID['id'] ) ) { continue; } $_aTaskIDs[] = $_aTaskID['id']; } return $_aTaskIDs; } }final class TaskScheduler_Occurrence_FixedInterval_Wizard extends TaskScheduler_Wizard_Occurrence_Base { public function construct() {} public function getFields() { return array( array( 'field_id' => 'interval', 'title' => __( 'Interval', 'task-scheduler' ), 'type' => 'number', array( 'type' => 'select', 'default' => 'minute', 'label' => array( 'second' => __( 'second(s)', 'task-scheduler' ), 'minute' => __( 'minute(s)', 'task-scheduler' ), 'hour' => __( 'hour(s)', 'task-scheduler' ), 'day' => __( 'day(s)', 'task-scheduler' ), ), ), ), ); } public function validateSettings( $aInput, $aOldInput, $oAdminPage ) { $_bIsValid = true; $_aErrors = array(); if ( ! isset( $aInput['interval'][ 0 ] ) || ! $aInput['interval'][ 0 ] ) { $_aErrors[ $this->_sSectionID ][ 'interval' ] = __( 'The interval must be greater than 0.', 'task-scheduler' ); $_bIsValid = false; } if ( ! $_bIsValid ) { $oAdminPage->setFieldErrors( $_aErrors ); $oAdminPage->setSettingNotice( __( 'Please try again.', 'task-scheduler' ) ); return array(); } return $aInput; } }final class TaskScheduler_Occurrence_SpecificTime_Wizard extends TaskScheduler_Wizard_Occurrence_Base { public function getFields() { return array( array( 'field_id' => 'when', 'title' => __( 'When', 'task-scheduler' ), 'type' => 'date_time', 'time_format' => 'hh:mm', 'repeatable' => true, 'attributes' => array( 'size' => 20, ), 'options' => "{
					numberOfMonths: 2,
					minDate: 0
				}" ), ); } public function validateSettings( $aInput, $aOldInput, $oAdminPage ) { $_bIsValid = true; $_aErrors = array(); $aInput['when'] = array_filter( $aInput['when'] ); if ( empty( $aInput['when'] ) ) { $_aErrors[ $this->_sSectionID ][ 'when' ] = __( 'At least one item needs to be set.', 'task-scheduler' ); $_bIsValid = false; } $_bUnset = false; foreach( $aInput['when'] as $_iIndex => $_sDateTime ) { $_iSetTimeStamp = strtotime( $_sDateTime ); $_iCurrentTimeStamp = current_time( 'timestamp', false ); if ( $_iSetTimeStamp < $_iCurrentTimeStamp ) { $_bUnset = true; unset( $aInput['when'][ $_iIndex ] ); } } if ( $_bUnset ) { $_bIsValid = false; $_sMessage = __( 'A future time needs to be set, not past.', 'task-scheduler' ); $_aErrors[ $this->_sSectionID ][ 'when' ] = isset( $_aErrors[ $this->_sSectionID ][ 'when' ] ) ? $_aErrors[ $this->_sSectionID ][ 'when' ] . '<br />' . $_sMessage : $_sMessage; } $aInput['when'] = array_values( $aInput['when'] ); if ( ! $_bIsValid ) { $oAdminPage->setFieldErrors( $_aErrors ); $oAdminPage->setSettingNotice( __( 'Please try again.', 'task-scheduler' ) ); } return $aInput; } }abstract class TaskScheduler_Routine_Base { public $ID; public $post_author = 0; public $post_date = '0000-00-00 00:00:00'; public $post_date_gmt = '0000-00-00 00:00:00'; public $post_content = ''; public $post_title = ''; public $post_excerpt = ''; public $post_status = 'publish'; public $comment_status = 'open'; public $ping_status = 'open'; public $post_password = ''; public $post_name = ''; public $to_ping = ''; public $pinged = ''; public $post_modified = '0000-00-00 00:00:00'; public $post_modified_gmt = '0000-00-00 00:00:00'; public $post_content_filtered = ''; public $post_parent = 0; public $guid = ''; public $menu_order = 0; public $post_type = 'post'; public $post_mime_type = ''; public $comment_count = 0; public $filter; public function __construct( $post ) { foreach ( get_object_vars( $post ) as $key => $value ) $this->$key = $value; } public function __isset( $key ) { if ( 'ancestors' == $key ) return true; if ( 'page_template' == $key ) return ( 'page' == $this->post_type ); if ( 'post_category' == $key ) return true; if ( 'tags_input' == $key ) return true; return metadata_exists( 'post', $this->ID, $key ); } public function __get( $key ) { if ( 'page_template' == $key && $this->__isset( $key ) ) { return get_post_meta( $this->ID, '_wp_page_template', true ); } if ( 'post_category' == $key ) { if ( is_object_in_taxonomy( $this->post_type, 'category' ) ) $terms = get_the_terms( $this, 'category' ); if ( empty( $terms ) ) return array(); return wp_list_pluck( $terms, 'term_id' ); } if ( 'tags_input' == $key ) { if ( is_object_in_taxonomy( $this->post_type, 'post_tag' ) ) $terms = get_the_terms( $this, 'post_tag' ); if ( empty( $terms ) ) return array(); return wp_list_pluck( $terms, 'name' ); } if ( 'ancestors' == $key ) $value = get_post_ancestors( $this ); else $value = get_post_meta( $this->ID, $key, true ); if ( $this->filter ) $value = sanitize_post_field( $key, $value, $this->ID, $this->filter ); return $value; } public function filter( $filter ) { if ( $this->filter == $filter ) return $this; if ( $filter == 'raw' ) return self::get_instance( $this->ID ); return sanitize_post( $this, $filter ); } public function to_array() { $post = get_object_vars( $this ); foreach ( array( 'ancestors', 'page_template', 'post_category', 'tags_input' ) as $key ) { if ( $this->__isset( $key ) ) $post[ $key ] = $this->__get( $key ); } return $post; } }abstract class TaskScheduler_Routine_Option extends TaskScheduler_Routine_Base { public function getReadableTime( $nTimestamp, $sDateTimeFormat='Y/m/d G:i:s', $bfAdjustGMT=false ) { return TaskScheduler_WPUtility::getSiteReadableDate( $nTimestamp, $sDateTimeFormat, $bfAdjustGMT ); } }abstract class TaskScheduler_Routine_Meta extends TaskScheduler_Routine_Option { public function setMeta( $sKey, $vValue ) { $this->$sKey = $vValue; update_post_meta( $this->ID, $sKey, $vValue ); } public function deleteMeta( $sKey ) { unset( $this->$sKey ); delete_post_meta( $this->ID, $sKey ); } public function getMeta( $sKey='' ) { if ( ! $sKey ) { $_aMeta = TaskScheduler_WPUtility::getPostMetas( $this->ID ) + ( $this->isTask() ? TaskScheduler_RoutineUtility::$aDefaultMeta : TaskScheduler_ThreadUtility::$aDefaultMeta ); $_aMeta['_max_execution_time'] = isset( $_aMeta['_max_execution_time'] ) ? $_aMeta['_max_execution_time'] : TaskScheduler_Utility::getServerAllowedMaxExecutionTime( 30 ); foreach( $_aMeta as $_sKey => $_vValue ) { $this->$_sKey = $_vValue; } return $_aMeta; } $this->$sKey = get_post_meta( $this->ID, $sKey, true ); return $this->$sKey; } }abstract class TaskScheduler_Routine_Log extends TaskScheduler_Routine_Meta { public function canLog( $iTargetTaskID=null ) { if ( $iTargetTaskID == $this->ID || is_null( $iTargetTaskID ) ) { return $this->_max_root_log_count ? true : false; } $_oTargetTask = TaskScheduler_Routine::getInstance( $iTargetTaskID ); return is_object( $_oTargetTask ) ? ( $_oTargetTask->_max_root_log_count ) : false; } public function log( $asLog, $iParentLogID=0, $bUpdateMeta=false ) { $_iTargetTaskID = ! $iParentLogID ? $this->ID : get_post_meta( $iParentLogID, '_routine_id', true ); if ( ! $this->canLog( $_iTargetTaskID ) ) { return 0; } if ( ! $iParentLogID && $this->isThread() ) { $iParentLogID = $this->parent_routine_log_id ? $this->parent_routine_log_id : 0; } $_iLogID = TaskScheduler_LogUtility::log( $iParentLogID ? $iParentLogID : $this->ID , $asLog ); if ( $bUpdateMeta ) { $this->setMeta( 'log_id', $_iLogID ); } return $_iLogID; } public function getLogCount() { return count( $this->getLogIDs() ); } public function getLogIDs() { return TaskScheduler_LogUtility::getLogIDs( $this->ID ); } public function getRootLogCount() { return count( $this->getRootLogIDs() ); } public function getRootLogIDs() { return TaskScheduler_LogUtility::getRootLogIDs( $this->ID ); } }class TaskScheduler_Log extends TaskScheduler_Routine_Log { static public function getInstance( $iPostID ) { global $wpdb; $_sClassName = get_class(); $iPostID = ( int ) $iPostID; if ( ! $iPostID ) { return false; } $_oPost = wp_cache_get( $iPostID, 'posts' ); if ( ! $_oPost ) { $_oPost = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->posts WHERE ID = %d LIMIT 1", $iPostID ) ); if ( ! $_oPost ) { return false; } $_oPost = sanitize_post( $_oPost, 'raw' ); wp_cache_add( $_oPost->ID, $_oPost, 'posts' ); } elseif ( empty( $_oPost->filter ) ) { $_oPost = sanitize_post( $_oPost, 'raw' ); } return new $_sClassName( $_oPost ); } }abstract class TaskScheduler_Routine_Thread extends TaskScheduler_Routine_Log { public function isThread() { return ( TaskScheduler_Registry::PostType_Thread == $this->post_type ); } public function getOwnerID() { return $this->isThread() ? $this->owner_routine_id : 0; } public function getOwner() { return $this->isThread() ? TaskScheduler_Routine::getInstance( $this->getOwnerID() ) : false; } public function getOwnerThreadCount() { return $this->isThread() ? TaskScheduler_RoutineUtility::getThreadCount( $this->getOwnerID() ) : 0; } }final class TaskScheduler_Routine extends TaskScheduler_Routine_Thread { static public function getInstance( $iPostID ) { global $wpdb; $_sClassName = get_class(); $iPostID = ( int ) $iPostID; if ( ! $iPostID ) { return false; } $_oPost = wp_cache_get( $iPostID, 'posts' ); if ( ! $_oPost ) { $_oPost = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->posts WHERE ID = %d LIMIT 1", $iPostID ) ); if ( ! $_oPost ) { return false; } $_oPost = sanitize_post( $_oPost, 'raw' ); wp_cache_add( $_oPost->ID, $_oPost, 'posts' ); } elseif ( empty( $_oPost->filter ) ) { $_oPost = sanitize_post( $_oPost, 'raw' ); } return new $_sClassName( $_oPost ); } public function setNextRunTime( $iTimeStamp=null ) { if ( ! $this->occurrence ) { return 0; } $iTimeStamp = apply_filters( "task_scheduler_filter_next_run_time_{$this->occurrence}", $iTimeStamp ? $iTimeStamp : $this->_next_run_time, $this ); $this->setMeta( '_next_run_time', $iTimeStamp ); return $iTimeStamp; } public function delete() { return wp_delete_post( $this->ID, true ); } public function start( $nTargetTime=null ) { do_action( 'task_scheduler_action_spawn_routine', $this->ID, $nTargetTime ); } public function resetCounts() { $this->setMeta( '_count_run', 0 ); $this->setMeta( '_count_exit', 0 ); $this->setMeta( '_count_call', 0 ); $this->setMeta( '_count_hung', 0 ); } public function resetStatus() { $this->setMeta( '_routine_status', 'inactive' ); $this->deleteMeta( '_is_spawned' ); $this->deleteMeta( '_spawned_time' ); } public function enable() { TaskScheduler_RoutineUtility::enable( $this->ID ); } public function disable() { TaskScheduler_RoutineUtility::disable( $this->ID ); } public function isEnabled() { return ( in_array( $this->post_status, array( 'publish', 'private' ) ) ); } public function isTask() { return ( TaskScheduler_Registry::PostType_Task == $this->post_type ); } public function hasThreads() { return TaskScheduler_RoutineUtility::hasThreads( $this->ID ); } public function getThreadCount() { return TaskScheduler_RoutineUtility::getThreadCount( $this->ID ); } public function getParentID() { } public function getParent() { } public function __get( $sName ) { if ( metadata_exists( 'post', $this->ID, $sName ) ) { $this->$sName = get_post_meta( $this->ID, $sName, true ); return $this->$sName; } if ( in_array( $sName, array( '_exit_code', '_is_spawned', '_spawned_time' ) ) ) { $this->$sName = null; return null; } if ( in_array( $sName, array( 'parent_routine_log_id', '_count_exit', '_count_run', '_count_call', '_count_hung' ) ) ) { $this->$sName = 0; return 0; } return parent::__get( $sName ); } }final class TaskScheduler_Option { public $sOptionKey; static public $aDefaults = array( 'server_heartbeat' => array( 'power' => true, 'interval' => 24, 'query_string' => array( 0 => true, 1 => 'doing_server_heartbeat', ), ), 'email' => array( 'message_body' => null, ), 'task_default' => array( 'max_root_log_count' => 0, 'max_execution_time' => 30, ), 'routine' => array( 'max_background_routine_count' => 12, ), 'reset' => array( 'reset_upon_deactivation' => false, ), ); static public $oInstance; public function __construct( $sOptionKey ) { $this->sOptionKey = $sOptionKey; $_aDefaults = $this->_formatDefaults( self::$aDefaults ); $this->aOptions = TaskScheduler_Utility::uniteArrays( get_option( $this->sOptionKey, array() ), $_aDefaults ); } private function _formatDefaults( array $aDefaults ) { $_iServerAllowedMaxExecutionTime = TaskScheduler_Utility::getServerAllowedMaxExecutionTime( 30 ); $aDefaults['server_heartbeat']['interval'] = $_iServerAllowedMaxExecutionTime ? round( $_iServerAllowedMaxExecutionTime * 8 / 10 ) : $aDefaults['server_heartbeat']['interval']; $aDefaults['task_default']['max_execution_time'] = 0 === $_iServerAllowedMaxExecutionTime ? $aDefaults['task_default']['max_execution_time'] : $_iServerAllowedMaxExecutionTime; return $aDefaults; } static public function getInstance() { self::$oInstance = self::$oInstance ? self::$oInstance : new TaskScheduler_Option( TaskScheduler_Registry::OptionKey ); return self::$oInstance; } static public function refresh() { self::$oInstanc = null; self::getInstance(); } static public function get( $asKey=null, $vDefault=null ) { $_oOption = self::getInstance(); if ( ! $asKey ) { return empty( $_oOption->aOptions ) ? $vDefault : $_oOption->aOptions; } return TaskScheduler_AdminPageFramework_WPUtility::getArrayValueByArrayKeys( $_oOption->aOptions, array_values( TaskScheduler_AdminPageFramework_WPUtility::getAsArray( $asKey ) ), $vDefault ); } }abstract class TaskScheduler_PostType_Log_Base extends TaskScheduler_AdminPageFramework_PostType { public function start() { $this->setPostTypeArgs( array( 'labels' => array( 'name' => __( 'Task Scheduler Log', 'task-scheduler' ), 'all_items' => __( 'Logs', 'task-scheduler' ), 'singular_name' => __( 'Log', 'task-scheduler' ), 'menu_name' => __( 'Logs', 'task-scheduler' ), 'add_new' => __( 'Add New Log', 'task-scheduler' ), 'add_new_item' => __( 'Add New Log', 'task-scheduler' ), 'edit' => __( 'Edit', 'task-scheduler' ), 'edit_item' => __( 'Edit Log', 'task-scheduler' ), 'new_item' => __( 'New Log', 'task-scheduler' ), 'view' => __( 'View', 'task-scheduler' ), 'view_item' => __( 'View Log', 'task-scheduler' ), 'search_items' => __( 'Search Logs', 'task-scheduler' ), 'not_found' => __( 'No Log found for Task Scheduler', 'task-scheduler' ), 'not_found_in_trash' => __( 'No Log Found for Task Scheduler in Trash', 'task-scheduler' ), 'parent' => __( 'Parent Log', 'task-scheduler' ), 'plugin_listing_table_title_cell_link' => '', ), 'public' => true, 'show_ui' => true, 'show_in_menu' => 'TaskScheduler_AdminPage', 'menu_position' => 999, 'can_export' => true, 'supports' => array( 'title', 'editor', 'excerpt' ), 'taxonomies' => array( '' ), 'menu_icon' => TaskScheduler_Registry::getPluginURL( '/asset/image/menu_icon_16x16.png' ), 'has_archive' => false, 'hierarchical' => true, 'show_admin_column' => true, 'screen_icon' => TaskScheduler_Registry::getPluginURL( "/asset/image/screen_icon_32x32.png" ), 'exclude_from_search' => true, 'capabilities' => array( ), ) ); if ( $this->oProp->bIsAdmin && $this->oUtil->getCurrentPostType() == $this->oProp->sPostType ) { add_action( 'admin_head-edit.php', array( $this, '_replyToAddCustomCSS' ) ); add_action( 'pre_get_posts', array( $this, '_replyToSetDefautSortOrder' ) ); } } public function _replyToSetDefautSortOrder( $oWPQuery ) { if ( $oWPQuery->query['post_type'] != $this->oProp->sPostType ) { return; } $oWPQuery->set( 'orderby', 'date' ); $oWPQuery->set( 'order', 'DESC' ); } public function _replyToAddCustomCSS() { ?>
			<style type="text/css">
				.add-new-h2 { display: none; }
				.widefat .column-time { width: 14%; }
			</style>
			<?php
 } public function columns_ts_log( $aHeaderColumns ) { return array( 'cb' => '<input type="checkbox" />', 'title' => __( 'title', 'task-scheduler' ), 'time' => __( 'Time', 'task-scheduler' ), ) ; } public function sortable_columns_ts_log( $aSortableHeaderColumns ) { return $aSortableHeaderColumns + array( 'title' => 'title', 'time' => 'time', ); } public function cell_ts_log_time( $sCell, $iPostID ) { $_oLog = TaskScheduler_Log::getInstance( $iPostID ); return $_oLog->getReadableTime( mysql2date( 'U' , $_oLog->post_date ), 'Y/m/d G:i:s', true ); return 'hello!'; } }final class TaskScheduler_PostType_Log extends TaskScheduler_PostType_Log_Base {}abstract class TaskScheduler_PostType_Task_Base extends TaskScheduler_AdminPageFramework_PostType { public function start() { $this->setPostTypeArgs( array( 'labels' => array( 'name' => __( 'Task Scheduler', 'task-scheduler' ), 'all_items' => __( 'Tasks', 'task-scheduler' ), 'singular_name' => __( 'Task', 'task-scheduler' ), 'menu_name' => __( 'Task Scheduler', 'task-scheduler' ), 'add_new' => __( 'Add New Task', 'task-scheduler' ), 'add_new_item' => __( 'Add New Task', 'task-scheduler' ), 'edit' => __( 'Edit', 'task-scheduler' ), 'edit_item' => __( 'Edit Task', 'task-scheduler' ), 'new_item' => __( 'New Task', 'task-scheduler' ), 'view' => __( 'View', 'task-scheduler' ), 'view_item' => __( 'View Tasks', 'task-scheduler' ), 'search_items' => __( 'Search Tasks', 'task-scheduler' ), 'not_found' => __( 'No Task found for Task Scheduler', 'task-scheduler' ), 'not_found_in_trash' => __( 'No Task Found for Task Scheduler in Trash', 'task-scheduler' ), 'parent' => __( 'Parent Task', 'task-scheduler' ), 'plugin_listing_table_title_cell_link' => '', ), 'public' => true, 'show_ui' => true, 'show_in_menu' => false, 'menu_position' => 110, 'can_export' => true, 'supports' => array( 'title', ), 'taxonomies' => array( TaskScheduler_Registry::Taxonomy_SystemLabel, ), 'menu_icon' => TaskScheduler_Registry::getPluginURL( '/asset/image/menu_icon_16x16.png' ), 'has_archive' => false, 'hierarchical' => true, 'show_admin_column' => true, 'screen_icon' => TaskScheduler_Registry::getPluginURL( "/asset/image/screen_icon_32x32.png" ), 'exclude_from_search' => true, 'capabilities' => array( ), ) ); $this->addTaxonomy( TaskScheduler_Registry::Taxonomy_SystemLabel, array( 'labels' => array( 'name' => __( 'Task Scheduler System Label', 'task-scheduler' ), 'add_new_item' => __( 'Add New Label', 'task-scheduler' ), 'new_item_name' => __( 'New Label', 'task-scheduler' ), ), 'show_ui' => false, 'show_tagcloud' => false, 'hierarchical' => false, 'show_admin_column' => true, 'show_in_nav_menus' => false, 'show_table_filter' => true, 'show_in_sidebar_menus' => false, ), array( TaskScheduler_Registry::PostType_Thread ) ); if ( $this->oProp->bIsAdmin && $this->oUtil->getCurrentPostType() == $this->oProp->sPostType ) { add_filter( 'enter_title_here', array( $this, '_replyToChangeTitleMetaBoxFieldLabel' ) ); add_action( 'edit_form_after_title', array( $this, '_replyToAddTextAfterTitle' ) ); add_action( 'admin_head-edit.php', array( $this, '_replyToAddCustomColumnCSS' ) ); add_action( 'pre_get_posts', array( $this, '_replyToSetDefaultSortOrder' ) ); add_filter( 'page_row_actions', array( $this, '_repyToRemoveQuickEdit' ), 10, 2 ); $this->setAutoSave( false ); $this->setAuthorTableFilter( true ); if ( in_array( $this->oUtil->getPageNow(), array( 'post.php', 'post-new.php' ) ) ) { add_filter( 'gettext', array( $this, '_replyToChangePublishButtonLabel' ), 10, 2 ); add_filter( 'post_updated_messages', array( $this, '_replyToChangeUpdatedMessage' ) ); } } add_filter( 'the_content', array( $this, '_replyToShowTaskDetails' ) ); } public function _replyToShowTaskDetails( $sContent ) { global $post; if ( $post->post_type != $this->oProp->sPostType ) { return $sContent; } if( ! is_singular() || ! is_main_query() ) { return $sContent; } $_aPageListArgs = array( 'authors' => '', 'child_of' => $post->ID, 'date_format' => 'Y/m/d G:i:s', 'depth' => 0, 'echo' => false, 'exclude' => '', 'include' => '', 'link_after' => '', 'link_before' => '', 'post_type' => TaskScheduler_Registry::PostType_Log, 'post_status' => array( 'private', 'publish' ), 'show_date' => true, 'sort_column' => 'post_date', 'sort_order' => 'DESC', 'title_li' => '', 'walker' => new TaskScheduler_Walker_Log, 'hierarchical' => true, ); return $sContent . "<h3>" . __( 'Log', 'task-scheduler' ) . "</h3>" . "<ul>" . wp_list_pages( $_aPageListArgs ) . "</ul>"; } public function _replyToSetDefaultSortOrder( $oQuery ) { if ( $oQuery->get( 'post_type' ) != $this->oProp->sPostType ) { return; } if ( ! isset( $_GET['orderby'], $_GET['order'] ) ) { $oQuery->set( 'orderby', 'ID' ); $oQuery->set( 'order', 'DESC' ); } } public function _replyToAddCustomColumnCSS() { return; } public function _repyToRemoveQuickEdit( $aActions, $oPost ) { if ( $this->oUtil->getCurrentPostType() != $this->oProp->sPostType ) { return $aActions; } unset( $aActions['inline hide-if-no-js'] ); $aActions['run_now'] = "<a href=''>" . __( 'Run Now', 'task-scheduler' ) . "</a>"; return $aActions; } public function _replyToChangeTitleMetaBoxFieldLabel( $sText ) { return __( 'Set the task name here.', 'task-scheduler' ); } public function _replyToAddTextAfterTitle() { } public function _replyToChangePublishButtonLabel( $_sTranslation, $sText ) { if ( 'Publish' == $sText ) { return __( 'Create', 'task-scheduler' ); } return $_sTranslation; } public function _replyToChangeUpdatedMessage( $aMessages ) { $aMessages['post'][ 1 ] = __( 'Task updated', 'task-scheduler' ); $aMessages['post'][ 4 ] = __( 'Task updated', 'task-scheduler' ); $aMessages['post'][ 6 ] = __( 'Task created', 'task-scheduler' ); $aMessages['post'][ 7 ] = __( 'Task saved', 'task-scheduler' ); $aMessages['post'][ 8 ] = __( 'Task submitted', 'task-scheduler' ); return $aMessages; } }final class TaskScheduler_PostType_Task extends TaskScheduler_PostType_Task_Base {}abstract class TaskScheduler_PostType_Thread_Base extends TaskScheduler_AdminPageFramework_PostType { public function start() { $this->setPostTypeArgs( array( 'labels' => array( 'name' => __( 'Task Threads ', 'task-scheduler' ), 'all_items' => __( 'Manage Threads', 'task-scheduler' ), 'singular_name' => __( 'Task Thread', 'task-scheduler' ), 'menu_name' => __( 'Task Thread', 'task-scheduler' ), 'add_new' => __( 'Add New Thread', 'task-scheduler' ), 'add_new_item' => __( 'Add New Thread', 'task-scheduler' ), 'edit' => __( 'Edit', 'task-scheduler' ), 'edit_item' => __( 'Edit Thread', 'task-scheduler' ), 'new_item' => __( 'New Thread', 'task-scheduler' ), 'view' => __( 'View', 'task-scheduler' ), 'view_item' => __( 'View Threads', 'task-scheduler' ), 'search_items' => __( 'Search Threads', 'task-scheduler' ), 'not_found' => __( 'No Thread found for Task Scheduler', 'task-scheduler' ), 'not_found_in_trash' => __( 'No Thread Found for Task Scheduler in Trash', 'task-scheduler' ), 'parent' => __( 'Parent Thread', 'task-scheduler' ), 'plugin_listing_table_title_cell_link' => '', ), 'public' => true, 'show_ui' => false, 'show_in_menu' => false, 'menu_position' => 110, 'can_export' => true, 'supports' => array( 'title' ), 'taxonomies' => array( TaskScheduler_Registry::Taxonomy_SystemLabel, ), 'menu_icon' => TaskScheduler_Registry::getPluginURL( '/asset/image/menu_icon_16x16.png' ), 'has_archive' => false, 'hierarchical' => true, 'show_admin_column' => true, 'screen_icon' => TaskScheduler_Registry::getPluginURL( "/asset/image/screen_icon_32x32.png" ), 'exclude_from_search' => true, 'capabilities' => array( ), ) ); } }final class TaskScheduler_PostType_Thread extends TaskScheduler_PostType_Thread_Base {}if ( ! class_exists( 'Walker_Page' ) ) { include_once( ABSPATH . WPINC . '/post-template.php' ); } class TaskScheduler_Walker_Log extends Walker_Page { function start_el( &$sOutput, $oLog, $iDepth=0, $aArgs=array(), $iCurrentPage=0 ) { $_aOutput = array( $sOutput ); $_aOutput[] = ( $iDepth ? str_repeat( "\t", $iDepth ) : '' ) . '<li class="' . $this->_getCSSClass( $oLog, $iDepth, $aArgs, $iCurrentPage ) . '">' . '<a href="' . get_permalink( $oLog->ID ) . '">' . $aArgs['link_before'] . sprintf( __( '#%d' ), $oLog->ID ) . $aArgs['link_after'] . '</a>'; $_aOutput[] = TaskScheduler_WPUtility::getRedableMySQLDate( 'modified' == $aArgs['show_date'] ? $oLog->post_modified : $oLog->post_date, $aArgs['date_format'], false ); $_aOutput[] = $oLog->post_excerpt ? $oLog->post_excerpt : $this->_getExcerpt( $oLog->post_content ); $sOutput = implode( " ", $_aOutput ); } private function _getExcerpt( $sText, $iMaxChars=250 ) { $_sSubstr = function_exists( 'mb_substr' ) ? 'mb_substr' : 'substr'; $_sStrlen = function_exists( 'mb_strlen' ) ? 'mb_strlen' : 'strlen'; return $_sSubstr( $sText, 0, $iMaxChars ) . ( $_sStrlen( $sText ) > $iMaxChars ? '...' : '' ); } private function _getCSSClass( $oLog, $iDepth, $aArgs, $iCurrentPage ) { $_aCSSClass = array( 'page_item', 'page-item-' . $oLog->ID ); if( isset( $aArgs['pages_with_children'][ $oLog->ID ] ) ) { $_aCSSClass[] = 'page_item_has_children'; } if ( ! empty( $iCurrentPage ) ) { $_oCurrentLog = get_post( $iCurrentPage ); if ( in_array( $oLog->ID, $_oCurrentLog->ancestors ) ) $_aCSSClass[] = 'current_page_ancestor'; if ( $oLog->ID == $iCurrentPage ) $_aCSSClass[] = 'current_page_item'; elseif ( $_oCurrentLog && $oLog->ID == $_oCurrentLog->post_parent ) $_aCSSClass[] = 'current_page_parent'; } elseif ( $oLog->ID == get_option('page_for_posts') ) { $_aCSSClass[] = 'current_page_parent'; } return implode( ' ', apply_filters( 'page_css_class', $_aCSSClass, $oLog, $iDepth, $aArgs, $iCurrentPage ) ); } }